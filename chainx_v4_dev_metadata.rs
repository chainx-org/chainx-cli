# [allow (dead_code , unused_imports , non_camel_case_types)] pub mod api { # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] System (system :: Event) , # [codec (index = 2)] Scheduler (scheduler :: Event) , # [codec (index = 5)] Indices (indices :: Event) , # [codec (index = 6)] Balances (balances :: Event) , # [codec (index = 9)] Offences (offences :: Event) , # [codec (index = 11)] Session (session :: Event) , # [codec (index = 12)] Grandpa (grandpa :: Event) , # [codec (index = 13)] ImOnline (im_online :: Event) , # [codec (index = 15)] Democracy (democracy :: Event) , # [codec (index = 16)] Council (council :: Event) , # [codec (index = 17)] TechnicalCommittee (technical_committee :: Event) , # [codec (index = 18)] Elections (elections :: Event) , # [codec (index = 19)] TechnicalMembership (technical_membership :: Event) , # [codec (index = 20)] Treasury (treasury :: Event) , # [codec (index = 21)] Identity (identity :: Event) , # [codec (index = 22)] Utility (utility :: Event) , # [codec (index = 23)] Multisig (multisig :: Event) , # [codec (index = 24)] XSystem (x_system :: Event) , # [codec (index = 25)] XAssetsRegistrar (x_assets_registrar :: Event) , # [codec (index = 26)] XAssets (x_assets :: Event) , # [codec (index = 27)] XStaking (x_staking :: Event) , # [codec (index = 28)] XMiningAsset (x_mining_asset :: Event) , # [codec (index = 29)] XGatewayRecords (x_gateway_records :: Event) , # [codec (index = 30)] XGatewayCommon (x_gateway_common :: Event) , # [codec (index = 31)] XGatewayBitcoin (x_gateway_bitcoin :: Event) , # [codec (index = 32)] XSpot (x_spot :: Event) , # [codec (index = 34)] Currencies (currencies :: Event) , # [codec (index = 35)] XTransactionFee (x_transaction_fee :: Event) , # [codec (index = 36)] Proxy (proxy :: Event) , # [codec (index = 37)] Bounties (bounties :: Event) , # [codec (index = 38)] Tips (tips :: Event) , # [codec (index = 39)] Sudo (sudo :: Event) , } pub mod system { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct FillBlock { pub ratio : runtime_types :: sp_arithmetic :: per_things :: Perbill } impl :: subxt :: Call for FillBlock { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "fill_block" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Remark { pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for Remark { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "remark" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetHeapPages { pub pages : :: core :: primitive :: u64 } impl :: subxt :: Call for SetHeapPages { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "set_heap_pages" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetCode { pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for SetCode { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "set_code" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetCodeWithoutChecks { pub code : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for SetCodeWithoutChecks { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "set_code_without_checks" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetChangesTrieConfig { pub changes_trie_config : :: core :: option :: Option < runtime_types :: sp_core :: changes_trie :: ChangesTrieConfiguration > } impl :: subxt :: Call for SetChangesTrieConfig { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "set_changes_trie_config" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetStorage { pub items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > } impl :: subxt :: Call for SetStorage { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "set_storage" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct KillStorage { pub keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > } impl :: subxt :: Call for KillStorage { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "kill_storage" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct KillPrefix { pub prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub subkeys : :: core :: primitive :: u32 } impl :: subxt :: Call for KillPrefix { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "kill_prefix" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemarkWithEvent { pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for RemarkWithEvent { const PALLET : & 'static str = "System" ; const FUNCTION : & 'static str = "remark_with_event" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn fill_block (& self , ratio : runtime_types :: sp_arithmetic :: per_things :: Perbill ,) -> :: subxt :: SubmittableExtrinsic < T , FillBlock > { let call = FillBlock { ratio , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remark (& self , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , Remark > { let call = Remark { remark , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_heap_pages (& self , pages : :: core :: primitive :: u64 ,) -> :: subxt :: SubmittableExtrinsic < T , SetHeapPages > { let call = SetHeapPages { pages , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_code (& self , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , SetCode > { let call = SetCode { code , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_code_without_checks (& self , code : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , SetCodeWithoutChecks > { let call = SetCodeWithoutChecks { code , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_changes_trie_config (& self , changes_trie_config : :: core :: option :: Option < runtime_types :: sp_core :: changes_trie :: ChangesTrieConfiguration > ,) -> :: subxt :: SubmittableExtrinsic < T , SetChangesTrieConfig > { let call = SetChangesTrieConfig { changes_trie_config , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_storage (& self , items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > ,) -> :: subxt :: SubmittableExtrinsic < T , SetStorage > { let call = SetStorage { items , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn kill_storage (& self , keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ,) -> :: subxt :: SubmittableExtrinsic < T , KillStorage > { let call = KillStorage { keys , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn kill_prefix (& self , prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , subkeys : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , KillPrefix > { let call = KillPrefix { prefix , subkeys , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remark_with_event (& self , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , RemarkWithEvent > { let call = RemarkWithEvent { remark , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: frame_system :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ExtrinsicSuccess (pub runtime_types :: frame_support :: weights :: DispatchInfo) ; impl :: subxt :: Event for ExtrinsicSuccess { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicSuccess" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ExtrinsicFailed (pub runtime_types :: sp_runtime :: DispatchError , pub runtime_types :: frame_support :: weights :: DispatchInfo) ; impl :: subxt :: Event for ExtrinsicFailed { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "ExtrinsicFailed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CodeUpdated { } impl :: subxt :: Event for CodeUpdated { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "CodeUpdated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NewAccount (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for NewAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "NewAccount" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct KilledAccount (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for KilledAccount { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "KilledAccount" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Remarked (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for Remarked { const PALLET : & 'static str = "System" ; const EVENT : & 'static str = "Remarked" ; } } pub mod storage { use super :: runtime_types ; pub struct Account (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Account { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "Account" ; type Value = runtime_types :: frame_system :: AccountInfo < :: core :: primitive :: u32 , runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct ExtrinsicCount ; impl :: subxt :: StorageEntry for ExtrinsicCount { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "ExtrinsicCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct BlockWeight ; impl :: subxt :: StorageEntry for BlockWeight { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "BlockWeight" ; type Value = runtime_types :: frame_support :: weights :: PerDispatchClass < :: core :: primitive :: u64 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct AllExtrinsicsLen ; impl :: subxt :: StorageEntry for AllExtrinsicsLen { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "AllExtrinsicsLen" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct BlockHash (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for BlockHash { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "BlockHash" ; type Value = :: subxt :: sp_core :: H256 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ExtrinsicData (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ExtrinsicData { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "ExtrinsicData" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Number ; impl :: subxt :: StorageEntry for Number { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "Number" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ParentHash ; impl :: subxt :: StorageEntry for ParentHash { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "ParentHash" ; type Value = :: subxt :: sp_core :: H256 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Digest ; impl :: subxt :: StorageEntry for Digest { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "Digest" ; type Value = runtime_types :: sp_runtime :: generic :: digest :: Digest < :: subxt :: sp_core :: H256 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Events ; impl :: subxt :: StorageEntry for Events { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "Events" ; type Value = :: std :: vec :: Vec < runtime_types :: frame_system :: EventRecord < runtime_types :: dev_runtime :: Event , :: subxt :: sp_core :: H256 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct EventCount ; impl :: subxt :: StorageEntry for EventCount { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "EventCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct EventTopics (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for EventTopics { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "EventTopics" ; type Value = :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct LastRuntimeUpgrade ; impl :: subxt :: StorageEntry for LastRuntimeUpgrade { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "LastRuntimeUpgrade" ; type Value = runtime_types :: frame_system :: LastRuntimeUpgradeInfo ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct UpgradedToU32RefCount ; impl :: subxt :: StorageEntry for UpgradedToU32RefCount { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "UpgradedToU32RefCount" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct UpgradedToTripleRefCount ; impl :: subxt :: StorageEntry for UpgradedToTripleRefCount { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "UpgradedToTripleRefCount" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ExecutionPhase ; impl :: subxt :: StorageEntry for ExecutionPhase { const PALLET : & 'static str = "System" ; const STORAGE : & 'static str = "ExecutionPhase" ; type Value = runtime_types :: frame_system :: Phase ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn account (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_system :: AccountInfo < :: core :: primitive :: u32 , runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > > , :: subxt :: Error > { let entry = Account (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn account_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Account > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn extrinsic_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = ExtrinsicCount ; self . client . storage () . fetch (& entry , hash) . await } pub async fn block_weight (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: weights :: PerDispatchClass < :: core :: primitive :: u64 > , :: subxt :: Error > { let entry = BlockWeight ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn all_extrinsics_len (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = AllExtrinsicsLen ; self . client . storage () . fetch (& entry , hash) . await } pub async fn block_hash (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: sp_core :: H256 , :: subxt :: Error > { let entry = BlockHash (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn block_hash_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , BlockHash > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn extrinsic_data (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: Error > { let entry = ExtrinsicData (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn extrinsic_data_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ExtrinsicData > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn number (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = Number ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn parent_hash (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: sp_core :: H256 , :: subxt :: Error > { let entry = ParentHash ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn digest (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_runtime :: generic :: digest :: Digest < :: subxt :: sp_core :: H256 > , :: subxt :: Error > { let entry = Digest ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn events (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: frame_system :: EventRecord < runtime_types :: dev_runtime :: Event , :: subxt :: sp_core :: H256 > > , :: subxt :: Error > { let entry = Events ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn event_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = EventCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn event_topics (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: Error > { let entry = EventTopics (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn event_topics_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , EventTopics > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn last_runtime_upgrade (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: frame_system :: LastRuntimeUpgradeInfo > , :: subxt :: Error > { let entry = LastRuntimeUpgrade ; self . client . storage () . fetch (& entry , hash) . await } pub async fn upgraded_to_u32_ref_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = UpgradedToU32RefCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn upgraded_to_triple_ref_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = UpgradedToTripleRefCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn execution_phase (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: frame_system :: Phase > , :: subxt :: Error > { let entry = ExecutionPhase ; self . client . storage () . fetch (& entry , hash) . await } } } } pub mod scheduler { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Schedule { pub when : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : runtime_types :: dev_runtime :: Call } impl :: subxt :: Call for Schedule { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "schedule" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Cancel { pub when : :: core :: primitive :: u32 , pub index : :: core :: primitive :: u32 } impl :: subxt :: Call for Cancel { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "cancel" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ScheduleNamed { pub id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub when : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : runtime_types :: dev_runtime :: Call } impl :: subxt :: Call for ScheduleNamed { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "schedule_named" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CancelNamed { pub id : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for CancelNamed { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "cancel_named" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ScheduleAfter { pub after : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : runtime_types :: dev_runtime :: Call } impl :: subxt :: Call for ScheduleAfter { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "schedule_after" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ScheduleNamedAfter { pub id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub after : :: core :: primitive :: u32 , pub maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , pub priority : :: core :: primitive :: u8 , pub call : runtime_types :: dev_runtime :: Call } impl :: subxt :: Call for ScheduleNamedAfter { const PALLET : & 'static str = "Scheduler" ; const FUNCTION : & 'static str = "schedule_named_after" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn schedule (& self , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: dev_runtime :: Call ,) -> :: subxt :: SubmittableExtrinsic < T , Schedule > { let call = Schedule { when , maybe_periodic , priority , call , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn cancel (& self , when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Cancel > { let call = Cancel { when , index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn schedule_named (& self , id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: dev_runtime :: Call ,) -> :: subxt :: SubmittableExtrinsic < T , ScheduleNamed > { let call = ScheduleNamed { id , when , maybe_periodic , priority , call , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn cancel_named (& self , id : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , CancelNamed > { let call = CancelNamed { id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn schedule_after (& self , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: dev_runtime :: Call ,) -> :: subxt :: SubmittableExtrinsic < T , ScheduleAfter > { let call = ScheduleAfter { after , maybe_periodic , priority , call , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn schedule_named_after (& self , id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : runtime_types :: dev_runtime :: Call ,) -> :: subxt :: SubmittableExtrinsic < T , ScheduleNamedAfter > { let call = ScheduleNamedAfter { id , after , maybe_periodic , priority , call , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_scheduler :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Scheduled (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Scheduled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Scheduled" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Canceled (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Canceled { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Canceled" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Dispatched (pub (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , pub :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError >) ; impl :: subxt :: Event for Dispatched { const PALLET : & 'static str = "Scheduler" ; const EVENT : & 'static str = "Dispatched" ; } } pub mod storage { use super :: runtime_types ; pub struct Agenda (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Agenda { const PALLET : & 'static str = "Scheduler" ; const STORAGE : & 'static str = "Agenda" ; type Value = :: std :: vec :: Vec < :: core :: option :: Option < runtime_types :: pallet_scheduler :: ScheduledV2 < runtime_types :: dev_runtime :: Call , :: core :: primitive :: u32 , runtime_types :: dev_runtime :: OriginCaller , :: subxt :: sp_core :: crypto :: AccountId32 > > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Lookup (pub :: std :: vec :: Vec < :: core :: primitive :: u8 >) ; impl :: subxt :: StorageEntry for Lookup { const PALLET : & 'static str = "Scheduler" ; const STORAGE : & 'static str = "Lookup" ; type Value = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageVersion ; impl :: subxt :: StorageEntry for StorageVersion { const PALLET : & 'static str = "Scheduler" ; const STORAGE : & 'static str = "StorageVersion" ; type Value = runtime_types :: pallet_scheduler :: Releases ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn agenda (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: option :: Option < runtime_types :: pallet_scheduler :: ScheduledV2 < runtime_types :: dev_runtime :: Call , :: core :: primitive :: u32 , runtime_types :: dev_runtime :: OriginCaller , :: subxt :: sp_core :: crypto :: AccountId32 > > > , :: subxt :: Error > { let entry = Agenda (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn agenda_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Agenda > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn lookup (& self , _0 : :: std :: vec :: Vec < :: core :: primitive :: u8 > , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: Error > { let entry = Lookup (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn lookup_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Lookup > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn storage_version (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_scheduler :: Releases , :: subxt :: Error > { let entry = StorageVersion ; self . client . storage () . fetch_or_default (& entry , hash) . await } } } } pub mod babe { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ReportEquivocation { pub equivocation_proof : runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof } impl :: subxt :: Call for ReportEquivocation { const PALLET : & 'static str = "Babe" ; const FUNCTION : & 'static str = "report_equivocation" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ReportEquivocationUnsigned { pub equivocation_proof : runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof } impl :: subxt :: Call for ReportEquivocationUnsigned { const PALLET : & 'static str = "Babe" ; const FUNCTION : & 'static str = "report_equivocation_unsigned" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PlanConfigChange { pub config : runtime_types :: sp_consensus_babe :: digests :: NextConfigDescriptor } impl :: subxt :: Call for PlanConfigChange { const PALLET : & 'static str = "Babe" ; const FUNCTION : & 'static str = "plan_config_change" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn report_equivocation (& self , equivocation_proof : runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> :: subxt :: SubmittableExtrinsic < T , ReportEquivocation > { let call = ReportEquivocation { equivocation_proof , key_owner_proof , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn report_equivocation_unsigned (& self , equivocation_proof : runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> :: subxt :: SubmittableExtrinsic < T , ReportEquivocationUnsigned > { let call = ReportEquivocationUnsigned { equivocation_proof , key_owner_proof , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn plan_config_change (& self , config : runtime_types :: sp_consensus_babe :: digests :: NextConfigDescriptor ,) -> :: subxt :: SubmittableExtrinsic < T , PlanConfigChange > { let call = PlanConfigChange { config , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub mod storage { use super :: runtime_types ; pub struct EpochIndex ; impl :: subxt :: StorageEntry for EpochIndex { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "EpochIndex" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Authorities ; impl :: subxt :: StorageEntry for Authorities { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "Authorities" ; type Value = runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_consensus_babe :: app :: Public , :: core :: primitive :: u64 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct GenesisSlot ; impl :: subxt :: StorageEntry for GenesisSlot { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "GenesisSlot" ; type Value = runtime_types :: sp_consensus_slots :: Slot ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentSlot ; impl :: subxt :: StorageEntry for CurrentSlot { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "CurrentSlot" ; type Value = runtime_types :: sp_consensus_slots :: Slot ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Randomness ; impl :: subxt :: StorageEntry for Randomness { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "Randomness" ; type Value = [:: core :: primitive :: u8 ; 32usize] ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct PendingEpochConfigChange ; impl :: subxt :: StorageEntry for PendingEpochConfigChange { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "PendingEpochConfigChange" ; type Value = runtime_types :: sp_consensus_babe :: digests :: NextConfigDescriptor ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextRandomness ; impl :: subxt :: StorageEntry for NextRandomness { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "NextRandomness" ; type Value = [:: core :: primitive :: u8 ; 32usize] ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextAuthorities ; impl :: subxt :: StorageEntry for NextAuthorities { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "NextAuthorities" ; type Value = runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_consensus_babe :: app :: Public , :: core :: primitive :: u64 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SegmentIndex ; impl :: subxt :: StorageEntry for SegmentIndex { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "SegmentIndex" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct UnderConstruction (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for UnderConstruction { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "UnderConstruction" ; type Value = runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < [:: core :: primitive :: u8 ; 32usize] > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Initialized ; impl :: subxt :: StorageEntry for Initialized { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "Initialized" ; type Value = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct AuthorVrfRandomness ; impl :: subxt :: StorageEntry for AuthorVrfRandomness { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "AuthorVrfRandomness" ; type Value = :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct EpochStart ; impl :: subxt :: StorageEntry for EpochStart { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "EpochStart" ; type Value = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Lateness ; impl :: subxt :: StorageEntry for Lateness { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "Lateness" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct EpochConfig ; impl :: subxt :: StorageEntry for EpochConfig { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "EpochConfig" ; type Value = runtime_types :: sp_consensus_babe :: BabeEpochConfiguration ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextEpochConfig ; impl :: subxt :: StorageEntry for NextEpochConfig { const PALLET : & 'static str = "Babe" ; const STORAGE : & 'static str = "NextEpochConfig" ; type Value = runtime_types :: sp_consensus_babe :: BabeEpochConfiguration ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn epoch_index (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: Error > { let entry = EpochIndex ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn authorities (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_consensus_babe :: app :: Public , :: core :: primitive :: u64 ,) > , :: subxt :: Error > { let entry = Authorities ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn genesis_slot (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_consensus_slots :: Slot , :: subxt :: Error > { let entry = GenesisSlot ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn current_slot (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_consensus_slots :: Slot , :: subxt :: Error > { let entry = CurrentSlot ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn randomness (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < [:: core :: primitive :: u8 ; 32usize] , :: subxt :: Error > { let entry = Randomness ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn pending_epoch_config_change (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: sp_consensus_babe :: digests :: NextConfigDescriptor > , :: subxt :: Error > { let entry = PendingEpochConfigChange ; self . client . storage () . fetch (& entry , hash) . await } pub async fn next_randomness (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < [:: core :: primitive :: u8 ; 32usize] , :: subxt :: Error > { let entry = NextRandomness ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn next_authorities (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_consensus_babe :: app :: Public , :: core :: primitive :: u64 ,) > , :: subxt :: Error > { let entry = NextAuthorities ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn segment_index (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = SegmentIndex ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn under_construction (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < [:: core :: primitive :: u8 ; 32usize] > , :: subxt :: Error > { let entry = UnderConstruction (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn under_construction_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , UnderConstruction > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn initialized (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > > , :: subxt :: Error > { let entry = Initialized ; self . client . storage () . fetch (& entry , hash) . await } pub async fn author_vrf_randomness (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < [:: core :: primitive :: u8 ; 32usize] > , :: subxt :: Error > { let entry = AuthorVrfRandomness ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn epoch_start (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , :: subxt :: Error > { let entry = EpochStart ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn lateness (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = Lateness ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn epoch_config (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: sp_consensus_babe :: BabeEpochConfiguration > , :: subxt :: Error > { let entry = EpochConfig ; self . client . storage () . fetch (& entry , hash) . await } pub async fn next_epoch_config (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: sp_consensus_babe :: BabeEpochConfiguration > , :: subxt :: Error > { let entry = NextEpochConfig ; self . client . storage () . fetch (& entry , hash) . await } } } } pub mod timestamp { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Set { # [codec (compact)] pub now : :: core :: primitive :: u64 } impl :: subxt :: Call for Set { const PALLET : & 'static str = "Timestamp" ; const FUNCTION : & 'static str = "set" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn set (& self , now : :: core :: primitive :: u64 ,) -> :: subxt :: SubmittableExtrinsic < T , Set > { let call = Set { now , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub mod storage { use super :: runtime_types ; pub struct Now ; impl :: subxt :: StorageEntry for Now { const PALLET : & 'static str = "Timestamp" ; const STORAGE : & 'static str = "Now" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DidUpdate ; impl :: subxt :: StorageEntry for DidUpdate { const PALLET : & 'static str = "Timestamp" ; const STORAGE : & 'static str = "DidUpdate" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn now (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: Error > { let entry = Now ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn did_update (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = DidUpdate ; self . client . storage () . fetch_or_default (& entry , hash) . await } } } } pub mod indices { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Claim { pub index : :: core :: primitive :: u32 } impl :: subxt :: Call for Claim { const PALLET : & 'static str = "Indices" ; const FUNCTION : & 'static str = "claim" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Transfer { pub new : :: subxt :: sp_core :: crypto :: AccountId32 , pub index : :: core :: primitive :: u32 } impl :: subxt :: Call for Transfer { const PALLET : & 'static str = "Indices" ; const FUNCTION : & 'static str = "transfer" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Free { pub index : :: core :: primitive :: u32 } impl :: subxt :: Call for Free { const PALLET : & 'static str = "Indices" ; const FUNCTION : & 'static str = "free" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceTransfer { pub new : :: subxt :: sp_core :: crypto :: AccountId32 , pub index : :: core :: primitive :: u32 , pub freeze : :: core :: primitive :: bool } impl :: subxt :: Call for ForceTransfer { const PALLET : & 'static str = "Indices" ; const FUNCTION : & 'static str = "force_transfer" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Freeze { pub index : :: core :: primitive :: u32 } impl :: subxt :: Call for Freeze { const PALLET : & 'static str = "Indices" ; const FUNCTION : & 'static str = "freeze" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn claim (& self , index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Claim > { let call = Claim { index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn transfer (& self , new : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Transfer > { let call = Transfer { new , index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn free (& self , index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Free > { let call = Free { index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn force_transfer (& self , new : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 , freeze : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , ForceTransfer > { let call = ForceTransfer { new , index , freeze , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn freeze (& self , index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Freeze > { let call = Freeze { index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_indices :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct IndexAssigned (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for IndexAssigned { const PALLET : & 'static str = "Indices" ; const EVENT : & 'static str = "IndexAssigned" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct IndexFreed (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for IndexFreed { const PALLET : & 'static str = "Indices" ; const EVENT : & 'static str = "IndexFreed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct IndexFrozen (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for IndexFrozen { const PALLET : & 'static str = "Indices" ; const EVENT : & 'static str = "IndexFrozen" ; } } pub mod storage { use super :: runtime_types ; pub struct Accounts (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Accounts { const PALLET : & 'static str = "Indices" ; const STORAGE : & 'static str = "Accounts" ; type Value = (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: bool ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn accounts (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: bool ,) > , :: subxt :: Error > { let entry = Accounts (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn accounts_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Accounts > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod balances { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Transfer { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 } impl :: subxt :: Call for Transfer { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "transfer" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetBalance { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub new_free : :: core :: primitive :: u128 , # [codec (compact)] pub new_reserved : :: core :: primitive :: u128 } impl :: subxt :: Call for SetBalance { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "set_balance" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceTransfer { pub source : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 } impl :: subxt :: Call for ForceTransfer { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "force_transfer" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TransferKeepAlive { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 } impl :: subxt :: Call for TransferKeepAlive { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "transfer_keep_alive" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TransferAll { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub keep_alive : :: core :: primitive :: bool } impl :: subxt :: Call for TransferAll { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "transfer_all" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceUnreserve { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub amount : :: core :: primitive :: u128 } impl :: subxt :: Call for ForceUnreserve { const PALLET : & 'static str = "Balances" ; const FUNCTION : & 'static str = "force_unreserve" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn transfer (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Transfer > { let call = Transfer { dest , value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_balance (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , new_free : :: core :: primitive :: u128 , new_reserved : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , SetBalance > { let call = SetBalance { who , new_free , new_reserved , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn force_transfer (& self , source : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , ForceTransfer > { let call = ForceTransfer { source , dest , value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn transfer_keep_alive (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , TransferKeepAlive > { let call = TransferKeepAlive { dest , value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn transfer_all (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , keep_alive : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , TransferAll > { let call = TransferAll { dest , keep_alive , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn force_unreserve (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , ForceUnreserve > { let call = ForceUnreserve { who , amount , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_balances :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Endowed (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Endowed { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Endowed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct DustLost (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for DustLost { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "DustLost" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Transfer (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Transfer { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Transfer" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BalanceSet (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for BalanceSet { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "BalanceSet" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Deposit (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Deposit { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Deposit" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Reserved (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Reserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Reserved" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Unreserved (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Unreserved { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "Unreserved" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ReserveRepatriated (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128 , pub runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus) ; impl :: subxt :: Event for ReserveRepatriated { const PALLET : & 'static str = "Balances" ; const EVENT : & 'static str = "ReserveRepatriated" ; } } pub mod storage { use super :: runtime_types ; pub struct TotalIssuance ; impl :: subxt :: StorageEntry for TotalIssuance { const PALLET : & 'static str = "Balances" ; const STORAGE : & 'static str = "TotalIssuance" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Account (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Account { const PALLET : & 'static str = "Balances" ; const STORAGE : & 'static str = "Account" ; type Value = runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct Locks (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Locks { const PALLET : & 'static str = "Balances" ; const STORAGE : & 'static str = "Locks" ; type Value = runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_balances :: BalanceLock < :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct Reserves (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Reserves { const PALLET : & 'static str = "Balances" ; const STORAGE : & 'static str = "Reserves" ; type Value = runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageVersion ; impl :: subxt :: StorageEntry for StorageVersion { const PALLET : & 'static str = "Balances" ; const STORAGE : & 'static str = "StorageVersion" ; type Value = runtime_types :: pallet_balances :: Releases ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn total_issuance (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: Error > { let entry = TotalIssuance ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn account (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_balances :: AccountData < :: core :: primitive :: u128 > , :: subxt :: Error > { let entry = Account (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn account_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Account > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn locks (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_balances :: BalanceLock < :: core :: primitive :: u128 > > , :: subxt :: Error > { let entry = Locks (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn locks_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Locks > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn reserves (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < runtime_types :: pallet_balances :: ReserveData < [:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u128 > > , :: subxt :: Error > { let entry = Reserves (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn reserves_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Reserves > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn storage_version (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_balances :: Releases , :: subxt :: Error > { let entry = StorageVersion ; self . client . storage () . fetch_or_default (& entry , hash) . await } } } } pub mod transaction_payment { use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub struct NextFeeMultiplier ; impl :: subxt :: StorageEntry for NextFeeMultiplier { const PALLET : & 'static str = "TransactionPayment" ; const STORAGE : & 'static str = "NextFeeMultiplier" ; type Value = runtime_types :: sp_arithmetic :: fixed_point :: FixedU128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageVersion ; impl :: subxt :: StorageEntry for StorageVersion { const PALLET : & 'static str = "TransactionPayment" ; const STORAGE : & 'static str = "StorageVersion" ; type Value = runtime_types :: pallet_transaction_payment :: Releases ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn next_fee_multiplier (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: sp_arithmetic :: fixed_point :: FixedU128 , :: subxt :: Error > { let entry = NextFeeMultiplier ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn storage_version (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_transaction_payment :: Releases , :: subxt :: Error > { let entry = StorageVersion ; self . client . storage () . fetch_or_default (& entry , hash) . await } } } } pub mod authorship { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetUncles { pub new_uncles : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > > } impl :: subxt :: Call for SetUncles { const PALLET : & 'static str = "Authorship" ; const FUNCTION : & 'static str = "set_uncles" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn set_uncles (& self , new_uncles : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > > ,) -> :: subxt :: SubmittableExtrinsic < T , SetUncles > { let call = SetUncles { new_uncles , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub mod storage { use super :: runtime_types ; pub struct Uncles ; impl :: subxt :: StorageEntry for Uncles { const PALLET : & 'static str = "Authorship" ; const STORAGE : & 'static str = "Uncles" ; type Value = :: std :: vec :: Vec < runtime_types :: pallet_authorship :: UncleEntryItem < :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Author ; impl :: subxt :: StorageEntry for Author { const PALLET : & 'static str = "Authorship" ; const STORAGE : & 'static str = "Author" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DidSetUncles ; impl :: subxt :: StorageEntry for DidSetUncles { const PALLET : & 'static str = "Authorship" ; const STORAGE : & 'static str = "DidSetUncles" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn uncles (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: pallet_authorship :: UncleEntryItem < :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 > > , :: subxt :: Error > { let entry = Uncles ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn author (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = Author ; self . client . storage () . fetch (& entry , hash) . await } pub async fn did_set_uncles (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = DidSetUncles ; self . client . storage () . fetch_or_default (& entry , hash) . await } } } } pub mod offences { use super :: runtime_types ; pub type Event = runtime_types :: pallet_offences :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Offence (pub [:: core :: primitive :: u8 ; 16usize] , pub :: std :: vec :: Vec < :: core :: primitive :: u8 >) ; impl :: subxt :: Event for Offence { const PALLET : & 'static str = "Offences" ; const EVENT : & 'static str = "Offence" ; } } pub mod storage { use super :: runtime_types ; pub struct Reports (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Reports { const PALLET : & 'static str = "Offences" ; const STORAGE : & 'static str = "Reports" ; type Value = runtime_types :: sp_staking :: offence :: OffenceDetails < :: subxt :: sp_core :: crypto :: AccountId32 , (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ConcurrentReportsIndex ([:: core :: primitive :: u8 ; 16usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 >) ; impl :: subxt :: StorageEntry for ConcurrentReportsIndex { const PALLET : & 'static str = "Offences" ; const STORAGE : & 'static str = "ConcurrentReportsIndex" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: H256 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ReportsByKindIndex (pub [:: core :: primitive :: u8 ; 16usize]) ; impl :: subxt :: StorageEntry for ReportsByKindIndex { const PALLET : & 'static str = "Offences" ; const STORAGE : & 'static str = "ReportsByKindIndex" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn reports (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: sp_staking :: offence :: OffenceDetails < :: subxt :: sp_core :: crypto :: AccountId32 , (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 ,) > > , :: subxt :: Error > { let entry = Reports (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn reports_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Reports > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn concurrent_reports_index (& self , _0 : [:: core :: primitive :: u8 ; 16usize] , _1 : :: std :: vec :: Vec < :: core :: primitive :: u8 > , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: H256 > , :: subxt :: Error > { let entry = ConcurrentReportsIndex (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn concurrent_reports_index_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ConcurrentReportsIndex > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn reports_by_kind_index (& self , _0 : [:: core :: primitive :: u8 ; 16usize] , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: Error > { let entry = ReportsByKindIndex (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn reports_by_kind_index_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ReportsByKindIndex > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod historical { use super :: runtime_types ; } pub mod session { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetKeys { pub keys : runtime_types :: dev_runtime :: SessionKeys , pub proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for SetKeys { const PALLET : & 'static str = "Session" ; const FUNCTION : & 'static str = "set_keys" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PurgeKeys { } impl :: subxt :: Call for PurgeKeys { const PALLET : & 'static str = "Session" ; const FUNCTION : & 'static str = "purge_keys" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn set_keys (& self , keys : runtime_types :: dev_runtime :: SessionKeys , proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , SetKeys > { let call = SetKeys { keys , proof , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn purge_keys (& self ,) -> :: subxt :: SubmittableExtrinsic < T , PurgeKeys > { let call = PurgeKeys { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_session :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NewSession (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for NewSession { const PALLET : & 'static str = "Session" ; const EVENT : & 'static str = "NewSession" ; } } pub mod storage { use super :: runtime_types ; pub struct Validators ; impl :: subxt :: StorageEntry for Validators { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "Validators" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentIndex ; impl :: subxt :: StorageEntry for CurrentIndex { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "CurrentIndex" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct QueuedChanged ; impl :: subxt :: StorageEntry for QueuedChanged { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "QueuedChanged" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct QueuedKeys ; impl :: subxt :: StorageEntry for QueuedKeys { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "QueuedKeys" ; type Value = :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: dev_runtime :: SessionKeys ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DisabledValidators ; impl :: subxt :: StorageEntry for DisabledValidators { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "DisabledValidators" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextKeys (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for NextKeys { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "NextKeys" ; type Value = runtime_types :: dev_runtime :: SessionKeys ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct KeyOwner (runtime_types :: sp_core :: crypto :: KeyTypeId , :: std :: vec :: Vec < :: core :: primitive :: u8 >) ; impl :: subxt :: StorageEntry for KeyOwner { const PALLET : & 'static str = "Session" ; const STORAGE : & 'static str = "KeyOwner" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn validators (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = Validators ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn current_index (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = CurrentIndex ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn queued_changed (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = QueuedChanged ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn queued_keys (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: dev_runtime :: SessionKeys ,) > , :: subxt :: Error > { let entry = QueuedKeys ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn disabled_validators (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = DisabledValidators ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn next_keys (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: dev_runtime :: SessionKeys > , :: subxt :: Error > { let entry = NextKeys (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn next_keys_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , NextKeys > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn key_owner (& self , _0 : runtime_types :: sp_core :: crypto :: KeyTypeId , _1 : :: std :: vec :: Vec < :: core :: primitive :: u8 > , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = KeyOwner (_0 , _1) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn key_owner_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , KeyOwner > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod grandpa { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ReportEquivocation { pub equivocation_proof : runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof } impl :: subxt :: Call for ReportEquivocation { const PALLET : & 'static str = "Grandpa" ; const FUNCTION : & 'static str = "report_equivocation" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ReportEquivocationUnsigned { pub equivocation_proof : runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > , pub key_owner_proof : runtime_types :: sp_session :: MembershipProof } impl :: subxt :: Call for ReportEquivocationUnsigned { const PALLET : & 'static str = "Grandpa" ; const FUNCTION : & 'static str = "report_equivocation_unsigned" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NoteStalled { pub delay : :: core :: primitive :: u32 , pub best_finalized_block_number : :: core :: primitive :: u32 } impl :: subxt :: Call for NoteStalled { const PALLET : & 'static str = "Grandpa" ; const FUNCTION : & 'static str = "note_stalled" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn report_equivocation (& self , equivocation_proof : runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> :: subxt :: SubmittableExtrinsic < T , ReportEquivocation > { let call = ReportEquivocation { equivocation_proof , key_owner_proof , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn report_equivocation_unsigned (& self , equivocation_proof : runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > , key_owner_proof : runtime_types :: sp_session :: MembershipProof ,) -> :: subxt :: SubmittableExtrinsic < T , ReportEquivocationUnsigned > { let call = ReportEquivocationUnsigned { equivocation_proof , key_owner_proof , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn note_stalled (& self , delay : :: core :: primitive :: u32 , best_finalized_block_number : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , NoteStalled > { let call = NoteStalled { delay , best_finalized_block_number , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_grandpa :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NewAuthorities (pub :: std :: vec :: Vec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) >) ; impl :: subxt :: Event for NewAuthorities { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "NewAuthorities" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Paused { } impl :: subxt :: Event for Paused { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "Paused" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Resumed { } impl :: subxt :: Event for Resumed { const PALLET : & 'static str = "Grandpa" ; const EVENT : & 'static str = "Resumed" ; } } pub mod storage { use super :: runtime_types ; pub struct State ; impl :: subxt :: StorageEntry for State { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "State" ; type Value = runtime_types :: pallet_grandpa :: StoredState < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct PendingChange ; impl :: subxt :: StorageEntry for PendingChange { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "PendingChange" ; type Value = runtime_types :: pallet_grandpa :: StoredPendingChange < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextForced ; impl :: subxt :: StorageEntry for NextForced { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "NextForced" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Stalled ; impl :: subxt :: StorageEntry for Stalled { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "Stalled" ; type Value = (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentSetId ; impl :: subxt :: StorageEntry for CurrentSetId { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "CurrentSetId" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SetIdSession (pub :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for SetIdSession { const PALLET : & 'static str = "Grandpa" ; const STORAGE : & 'static str = "SetIdSession" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn state (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_grandpa :: StoredState < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = State ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn pending_change (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_grandpa :: StoredPendingChange < :: core :: primitive :: u32 > > , :: subxt :: Error > { let entry = PendingChange ; self . client . storage () . fetch (& entry , hash) . await } pub async fn next_forced (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = NextForced ; self . client . storage () . fetch (& entry , hash) . await } pub async fn stalled (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , :: subxt :: Error > { let entry = Stalled ; self . client . storage () . fetch (& entry , hash) . await } pub async fn current_set_id (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: Error > { let entry = CurrentSetId ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn set_id_session (& self , _0 : :: core :: primitive :: u64 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = SetIdSession (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn set_id_session_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , SetIdSession > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod im_online { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Heartbeat { pub heartbeat : runtime_types :: pallet_im_online :: Heartbeat < :: core :: primitive :: u32 > , pub signature : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Signature } impl :: subxt :: Call for Heartbeat { const PALLET : & 'static str = "ImOnline" ; const FUNCTION : & 'static str = "heartbeat" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn heartbeat (& self , heartbeat : runtime_types :: pallet_im_online :: Heartbeat < :: core :: primitive :: u32 > , signature : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Signature ,) -> :: subxt :: SubmittableExtrinsic < T , Heartbeat > { let call = Heartbeat { heartbeat , signature , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_im_online :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct HeartbeatReceived (pub runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public) ; impl :: subxt :: Event for HeartbeatReceived { const PALLET : & 'static str = "ImOnline" ; const EVENT : & 'static str = "HeartbeatReceived" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AllGood { } impl :: subxt :: Event for AllGood { const PALLET : & 'static str = "ImOnline" ; const EVENT : & 'static str = "AllGood" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SomeOffline (pub :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 ,) >) ; impl :: subxt :: Event for SomeOffline { const PALLET : & 'static str = "ImOnline" ; const EVENT : & 'static str = "SomeOffline" ; } } pub mod storage { use super :: runtime_types ; pub struct HeartbeatAfter ; impl :: subxt :: StorageEntry for HeartbeatAfter { const PALLET : & 'static str = "ImOnline" ; const STORAGE : & 'static str = "HeartbeatAfter" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Keys ; impl :: subxt :: StorageEntry for Keys { const PALLET : & 'static str = "ImOnline" ; const STORAGE : & 'static str = "Keys" ; type Value = runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ReceivedHeartbeats (:: core :: primitive :: u32 , :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ReceivedHeartbeats { const PALLET : & 'static str = "ImOnline" ; const STORAGE : & 'static str = "ReceivedHeartbeats" ; type Value = runtime_types :: frame_support :: traits :: misc :: WrapperOpaque < runtime_types :: pallet_im_online :: BoundedOpaqueNetworkState > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct AuthoredBlocks (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for AuthoredBlocks { const PALLET : & 'static str = "ImOnline" ; const STORAGE : & 'static str = "AuthoredBlocks" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn heartbeat_after (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = HeartbeatAfter ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn keys (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public > , :: subxt :: Error > { let entry = Keys ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn received_heartbeats (& self , _0 : :: core :: primitive :: u32 , _1 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: frame_support :: traits :: misc :: WrapperOpaque < runtime_types :: pallet_im_online :: BoundedOpaqueNetworkState > > , :: subxt :: Error > { let entry = ReceivedHeartbeats (_0 , _1) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn received_heartbeats_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ReceivedHeartbeats > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn authored_blocks (& self , _0 : :: core :: primitive :: u32 , _1 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = AuthoredBlocks (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn authored_blocks_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AuthoredBlocks > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod authority_discovery { use super :: runtime_types ; } pub mod democracy { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Propose { pub proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] pub value : :: core :: primitive :: u128 } impl :: subxt :: Call for Propose { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "propose" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Second { # [codec (compact)] pub proposal : :: core :: primitive :: u32 , # [codec (compact)] pub seconds_upper_bound : :: core :: primitive :: u32 } impl :: subxt :: Call for Second { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "second" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Vote { # [codec (compact)] pub ref_index : :: core :: primitive :: u32 , pub vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > } impl :: subxt :: Call for Vote { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "vote" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct EmergencyCancel { pub ref_index : :: core :: primitive :: u32 } impl :: subxt :: Call for EmergencyCancel { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "emergency_cancel" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ExternalPropose { pub proposal_hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for ExternalPropose { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "external_propose" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ExternalProposeMajority { pub proposal_hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for ExternalProposeMajority { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "external_propose_majority" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ExternalProposeDefault { pub proposal_hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for ExternalProposeDefault { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "external_propose_default" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct FastTrack { pub proposal_hash : :: subxt :: sp_core :: H256 , pub voting_period : :: core :: primitive :: u32 , pub delay : :: core :: primitive :: u32 } impl :: subxt :: Call for FastTrack { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "fast_track" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct VetoExternal { pub proposal_hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for VetoExternal { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "veto_external" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CancelReferendum { # [codec (compact)] pub ref_index : :: core :: primitive :: u32 } impl :: subxt :: Call for CancelReferendum { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "cancel_referendum" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CancelQueued { pub which : :: core :: primitive :: u32 } impl :: subxt :: Call for CancelQueued { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "cancel_queued" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Delegate { pub to : :: subxt :: sp_core :: crypto :: AccountId32 , pub conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , pub balance : :: core :: primitive :: u128 } impl :: subxt :: Call for Delegate { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "delegate" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Undelegate { } impl :: subxt :: Call for Undelegate { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "undelegate" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ClearPublicProposals { } impl :: subxt :: Call for ClearPublicProposals { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "clear_public_proposals" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NotePreimage { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for NotePreimage { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "note_preimage" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NotePreimageOperational { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for NotePreimageOperational { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "note_preimage_operational" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NoteImminentPreimage { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for NoteImminentPreimage { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "note_imminent_preimage" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NoteImminentPreimageOperational { pub encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for NoteImminentPreimageOperational { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "note_imminent_preimage_operational" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ReapPreimage { pub proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] pub proposal_len_upper_bound : :: core :: primitive :: u32 } impl :: subxt :: Call for ReapPreimage { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "reap_preimage" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Unlock { pub target : :: subxt :: sp_core :: crypto :: AccountId32 } impl :: subxt :: Call for Unlock { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "unlock" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemoveVote { pub index : :: core :: primitive :: u32 } impl :: subxt :: Call for RemoveVote { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "remove_vote" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemoveOtherVote { pub target : :: subxt :: sp_core :: crypto :: AccountId32 , pub index : :: core :: primitive :: u32 } impl :: subxt :: Call for RemoveOtherVote { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "remove_other_vote" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct EnactProposal { pub proposal_hash : :: subxt :: sp_core :: H256 , pub index : :: core :: primitive :: u32 } impl :: subxt :: Call for EnactProposal { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "enact_proposal" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Blacklist { pub proposal_hash : :: subxt :: sp_core :: H256 , pub maybe_ref_index : :: core :: option :: Option < :: core :: primitive :: u32 > } impl :: subxt :: Call for Blacklist { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "blacklist" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CancelProposal { # [codec (compact)] pub prop_index : :: core :: primitive :: u32 } impl :: subxt :: Call for CancelProposal { const PALLET : & 'static str = "Democracy" ; const FUNCTION : & 'static str = "cancel_proposal" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn propose (& self , proposal_hash : :: subxt :: sp_core :: H256 , value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Propose > { let call = Propose { proposal_hash , value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn second (& self , proposal : :: core :: primitive :: u32 , seconds_upper_bound : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Second > { let call = Second { proposal , seconds_upper_bound , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn vote (& self , ref_index : :: core :: primitive :: u32 , vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > ,) -> :: subxt :: SubmittableExtrinsic < T , Vote > { let call = Vote { ref_index , vote , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn emergency_cancel (& self , ref_index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , EmergencyCancel > { let call = EmergencyCancel { ref_index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn external_propose (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , ExternalPropose > { let call = ExternalPropose { proposal_hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn external_propose_majority (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , ExternalProposeMajority > { let call = ExternalProposeMajority { proposal_hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn external_propose_default (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , ExternalProposeDefault > { let call = ExternalProposeDefault { proposal_hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn fast_track (& self , proposal_hash : :: subxt :: sp_core :: H256 , voting_period : :: core :: primitive :: u32 , delay : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , FastTrack > { let call = FastTrack { proposal_hash , voting_period , delay , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn veto_external (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , VetoExternal > { let call = VetoExternal { proposal_hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn cancel_referendum (& self , ref_index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , CancelReferendum > { let call = CancelReferendum { ref_index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn cancel_queued (& self , which : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , CancelQueued > { let call = CancelQueued { which , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn delegate (& self , to : :: subxt :: sp_core :: crypto :: AccountId32 , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , balance : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Delegate > { let call = Delegate { to , conviction , balance , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn undelegate (& self ,) -> :: subxt :: SubmittableExtrinsic < T , Undelegate > { let call = Undelegate { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn clear_public_proposals (& self ,) -> :: subxt :: SubmittableExtrinsic < T , ClearPublicProposals > { let call = ClearPublicProposals { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn note_preimage (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , NotePreimage > { let call = NotePreimage { encoded_proposal , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn note_preimage_operational (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , NotePreimageOperational > { let call = NotePreimageOperational { encoded_proposal , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn note_imminent_preimage (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , NoteImminentPreimage > { let call = NoteImminentPreimage { encoded_proposal , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn note_imminent_preimage_operational (& self , encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , NoteImminentPreimageOperational > { let call = NoteImminentPreimageOperational { encoded_proposal , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn reap_preimage (& self , proposal_hash : :: subxt :: sp_core :: H256 , proposal_len_upper_bound : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , ReapPreimage > { let call = ReapPreimage { proposal_hash , proposal_len_upper_bound , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn unlock (& self , target : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: SubmittableExtrinsic < T , Unlock > { let call = Unlock { target , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_vote (& self , index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , RemoveVote > { let call = RemoveVote { index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_other_vote (& self , target : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , RemoveOtherVote > { let call = RemoveOtherVote { target , index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn enact_proposal (& self , proposal_hash : :: subxt :: sp_core :: H256 , index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , EnactProposal > { let call = EnactProposal { proposal_hash , index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn blacklist (& self , proposal_hash : :: subxt :: sp_core :: H256 , maybe_ref_index : :: core :: option :: Option < :: core :: primitive :: u32 > ,) -> :: subxt :: SubmittableExtrinsic < T , Blacklist > { let call = Blacklist { proposal_hash , maybe_ref_index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn cancel_proposal (& self , prop_index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , CancelProposal > { let call = CancelProposal { prop_index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_democracy :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Proposed (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Proposed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Tabled (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u128 , pub :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 >) ; impl :: subxt :: Event for Tabled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Tabled" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ExternalTabled { } impl :: subxt :: Event for ExternalTabled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "ExternalTabled" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Started (pub :: core :: primitive :: u32 , pub runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold) ; impl :: subxt :: Event for Started { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Started" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Passed (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Passed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Passed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NotPassed (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for NotPassed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "NotPassed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Cancelled (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Cancelled { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Cancelled" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Executed (pub :: core :: primitive :: u32 , pub :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError >) ; impl :: subxt :: Event for Executed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Delegated (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for Delegated { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Delegated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Undelegated (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for Undelegated { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Undelegated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Vetoed (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: H256 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Vetoed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Vetoed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PreimageNoted (pub :: subxt :: sp_core :: H256 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for PreimageNoted { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageNoted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PreimageUsed (pub :: subxt :: sp_core :: H256 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for PreimageUsed { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageUsed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PreimageInvalid (pub :: subxt :: sp_core :: H256 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for PreimageInvalid { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageInvalid" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PreimageMissing (pub :: subxt :: sp_core :: H256 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for PreimageMissing { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageMissing" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PreimageReaped (pub :: subxt :: sp_core :: H256 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128 , pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for PreimageReaped { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "PreimageReaped" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Blacklisted (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for Blacklisted { const PALLET : & 'static str = "Democracy" ; const EVENT : & 'static str = "Blacklisted" ; } } pub mod storage { use super :: runtime_types ; pub struct PublicPropCount ; impl :: subxt :: StorageEntry for PublicPropCount { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "PublicPropCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct PublicProps ; impl :: subxt :: StorageEntry for PublicProps { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "PublicProps" ; type Value = :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct DepositOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for DepositOf { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "DepositOf" ; type Value = (:: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: core :: primitive :: u128 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Preimages (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Preimages { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "Preimages" ; type Value = runtime_types :: pallet_democracy :: PreimageStatus < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct ReferendumCount ; impl :: subxt :: StorageEntry for ReferendumCount { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "ReferendumCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct LowestUnbaked ; impl :: subxt :: StorageEntry for LowestUnbaked { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "LowestUnbaked" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ReferendumInfoOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ReferendumInfoOf { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "ReferendumInfoOf" ; type Value = runtime_types :: pallet_democracy :: types :: ReferendumInfo < :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct VotingOf (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for VotingOf { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "VotingOf" ; type Value = runtime_types :: pallet_democracy :: vote :: Voting < :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Locks (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Locks { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "Locks" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct LastTabledWasExternal ; impl :: subxt :: StorageEntry for LastTabledWasExternal { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "LastTabledWasExternal" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NextExternal ; impl :: subxt :: StorageEntry for NextExternal { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "NextExternal" ; type Value = (:: subxt :: sp_core :: H256 , runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Blacklist (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Blacklist { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "Blacklist" ; type Value = (:: core :: primitive :: u32 , :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct Cancellations (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Cancellations { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "Cancellations" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct StorageVersion ; impl :: subxt :: StorageEntry for StorageVersion { const PALLET : & 'static str = "Democracy" ; const STORAGE : & 'static str = "StorageVersion" ; type Value = runtime_types :: pallet_democracy :: Releases ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn public_prop_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = PublicPropCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn public_props (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 ,) > , :: subxt :: Error > { let entry = PublicProps ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn deposit_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: core :: primitive :: u128 ,) > , :: subxt :: Error > { let entry = DepositOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn deposit_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , DepositOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn preimages (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_democracy :: PreimageStatus < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: Error > { let entry = Preimages (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn preimages_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Preimages > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn referendum_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = ReferendumCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn lowest_unbaked (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = LowestUnbaked ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn referendum_info_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_democracy :: types :: ReferendumInfo < :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: core :: primitive :: u128 > > , :: subxt :: Error > { let entry = ReferendumInfoOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn referendum_info_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ReferendumInfoOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn voting_of (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_democracy :: vote :: Voting < :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = VotingOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn voting_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , VotingOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn locks (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = Locks (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn locks_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Locks > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn last_tabled_was_external (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = LastTabledWasExternal ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn next_external (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: subxt :: sp_core :: H256 , runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold ,) > , :: subxt :: Error > { let entry = NextExternal ; self . client . storage () . fetch (& entry , hash) . await } pub async fn blacklist (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: core :: primitive :: u32 , :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) > , :: subxt :: Error > { let entry = Blacklist (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn blacklist_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Blacklist > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn cancellations (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = Cancellations (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn cancellations_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Cancellations > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn storage_version (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_democracy :: Releases > , :: subxt :: Error > { let entry = StorageVersion ; self . client . storage () . fetch (& entry , hash) . await } } } } pub mod council { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetMembers { pub new_members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , pub prime : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , pub old_count : :: core :: primitive :: u32 } impl :: subxt :: Call for SetMembers { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "set_members" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Execute { pub proposal : runtime_types :: dev_runtime :: Call , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 } impl :: subxt :: Call for Execute { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "execute" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Propose { # [codec (compact)] pub threshold : :: core :: primitive :: u32 , pub proposal : runtime_types :: dev_runtime :: Call , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 } impl :: subxt :: Call for Propose { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "propose" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Vote { pub proposal : :: subxt :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , pub approve : :: core :: primitive :: bool } impl :: subxt :: Call for Vote { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "vote" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Close { pub proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , # [codec (compact)] pub proposal_weight_bound : :: core :: primitive :: u64 , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 } impl :: subxt :: Call for Close { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "close" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct DisapproveProposal { pub proposal_hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for DisapproveProposal { const PALLET : & 'static str = "Council" ; const FUNCTION : & 'static str = "disapprove_proposal" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn set_members (& self , new_members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , prime : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , old_count : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetMembers > { let call = SetMembers { new_members , prime , old_count , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn execute (& self , proposal : runtime_types :: dev_runtime :: Call , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Execute > { let call = Execute { proposal , length_bound , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn propose (& self , threshold : :: core :: primitive :: u32 , proposal : runtime_types :: dev_runtime :: Call , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Propose > { let call = Propose { threshold , proposal , length_bound , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn vote (& self , proposal : :: subxt :: sp_core :: H256 , index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , Vote > { let call = Vote { proposal , index , approve , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn close (& self , proposal_hash : :: subxt :: sp_core :: H256 , index : :: core :: primitive :: u32 , proposal_weight_bound : :: core :: primitive :: u64 , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Close > { let call = Close { proposal_hash , index , proposal_weight_bound , length_bound , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn disapprove_proposal (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , DisapproveProposal > { let call = DisapproveProposal { proposal_hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_collective :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Proposed (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: H256 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Proposed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Voted (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: H256 , pub :: core :: primitive :: bool , pub :: core :: primitive :: u32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Voted { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Voted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Approved (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for Approved { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Approved" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Disapproved (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for Disapproved { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Disapproved" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Executed (pub :: subxt :: sp_core :: H256 , pub :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError >) ; impl :: subxt :: Event for Executed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MemberExecuted (pub :: subxt :: sp_core :: H256 , pub :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError >) ; impl :: subxt :: Event for MemberExecuted { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "MemberExecuted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Closed (pub :: subxt :: sp_core :: H256 , pub :: core :: primitive :: u32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Closed { const PALLET : & 'static str = "Council" ; const EVENT : & 'static str = "Closed" ; } } pub mod storage { use super :: runtime_types ; pub struct Proposals ; impl :: subxt :: StorageEntry for Proposals { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "Proposals" ; type Value = runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: H256 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ProposalOf (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for ProposalOf { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "ProposalOf" ; type Value = runtime_types :: dev_runtime :: Call ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct Voting (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Voting { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "Voting" ; type Value = runtime_types :: pallet_collective :: Votes < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct ProposalCount ; impl :: subxt :: StorageEntry for ProposalCount { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "ProposalCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Members ; impl :: subxt :: StorageEntry for Members { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "Members" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Prime ; impl :: subxt :: StorageEntry for Prime { const PALLET : & 'static str = "Council" ; const STORAGE : & 'static str = "Prime" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn proposals (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: H256 > , :: subxt :: Error > { let entry = Proposals ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn proposal_of (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: dev_runtime :: Call > , :: subxt :: Error > { let entry = ProposalOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn proposal_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ProposalOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn voting (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_collective :: Votes < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , :: subxt :: Error > { let entry = Voting (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn voting_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Voting > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn proposal_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = ProposalCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn members (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = Members ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn prime (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = Prime ; self . client . storage () . fetch (& entry , hash) . await } } } } pub mod technical_committee { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetMembers { pub new_members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , pub prime : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , pub old_count : :: core :: primitive :: u32 } impl :: subxt :: Call for SetMembers { const PALLET : & 'static str = "TechnicalCommittee" ; const FUNCTION : & 'static str = "set_members" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Execute { pub proposal : runtime_types :: dev_runtime :: Call , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 } impl :: subxt :: Call for Execute { const PALLET : & 'static str = "TechnicalCommittee" ; const FUNCTION : & 'static str = "execute" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Propose { # [codec (compact)] pub threshold : :: core :: primitive :: u32 , pub proposal : runtime_types :: dev_runtime :: Call , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 } impl :: subxt :: Call for Propose { const PALLET : & 'static str = "TechnicalCommittee" ; const FUNCTION : & 'static str = "propose" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Vote { pub proposal : :: subxt :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , pub approve : :: core :: primitive :: bool } impl :: subxt :: Call for Vote { const PALLET : & 'static str = "TechnicalCommittee" ; const FUNCTION : & 'static str = "vote" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Close { pub proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] pub index : :: core :: primitive :: u32 , # [codec (compact)] pub proposal_weight_bound : :: core :: primitive :: u64 , # [codec (compact)] pub length_bound : :: core :: primitive :: u32 } impl :: subxt :: Call for Close { const PALLET : & 'static str = "TechnicalCommittee" ; const FUNCTION : & 'static str = "close" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct DisapproveProposal { pub proposal_hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for DisapproveProposal { const PALLET : & 'static str = "TechnicalCommittee" ; const FUNCTION : & 'static str = "disapprove_proposal" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn set_members (& self , new_members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , prime : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , old_count : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetMembers > { let call = SetMembers { new_members , prime , old_count , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn execute (& self , proposal : runtime_types :: dev_runtime :: Call , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Execute > { let call = Execute { proposal , length_bound , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn propose (& self , threshold : :: core :: primitive :: u32 , proposal : runtime_types :: dev_runtime :: Call , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Propose > { let call = Propose { threshold , proposal , length_bound , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn vote (& self , proposal : :: subxt :: sp_core :: H256 , index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , Vote > { let call = Vote { proposal , index , approve , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn close (& self , proposal_hash : :: subxt :: sp_core :: H256 , index : :: core :: primitive :: u32 , proposal_weight_bound : :: core :: primitive :: u64 , length_bound : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Close > { let call = Close { proposal_hash , index , proposal_weight_bound , length_bound , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn disapprove_proposal (& self , proposal_hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , DisapproveProposal > { let call = DisapproveProposal { proposal_hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_collective :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Proposed (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: H256 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Proposed { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Voted (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: H256 , pub :: core :: primitive :: bool , pub :: core :: primitive :: u32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Voted { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Voted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Approved (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for Approved { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Approved" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Disapproved (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for Disapproved { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Disapproved" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Executed (pub :: subxt :: sp_core :: H256 , pub :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError >) ; impl :: subxt :: Event for Executed { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Executed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MemberExecuted (pub :: subxt :: sp_core :: H256 , pub :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError >) ; impl :: subxt :: Event for MemberExecuted { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "MemberExecuted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Closed (pub :: subxt :: sp_core :: H256 , pub :: core :: primitive :: u32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Closed { const PALLET : & 'static str = "TechnicalCommittee" ; const EVENT : & 'static str = "Closed" ; } } pub mod storage { use super :: runtime_types ; pub struct Proposals ; impl :: subxt :: StorageEntry for Proposals { const PALLET : & 'static str = "TechnicalCommittee" ; const STORAGE : & 'static str = "Proposals" ; type Value = runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: H256 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ProposalOf (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for ProposalOf { const PALLET : & 'static str = "TechnicalCommittee" ; const STORAGE : & 'static str = "ProposalOf" ; type Value = runtime_types :: dev_runtime :: Call ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct Voting (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Voting { const PALLET : & 'static str = "TechnicalCommittee" ; const STORAGE : & 'static str = "Voting" ; type Value = runtime_types :: pallet_collective :: Votes < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct ProposalCount ; impl :: subxt :: StorageEntry for ProposalCount { const PALLET : & 'static str = "TechnicalCommittee" ; const STORAGE : & 'static str = "ProposalCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Members ; impl :: subxt :: StorageEntry for Members { const PALLET : & 'static str = "TechnicalCommittee" ; const STORAGE : & 'static str = "Members" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Prime ; impl :: subxt :: StorageEntry for Prime { const PALLET : & 'static str = "TechnicalCommittee" ; const STORAGE : & 'static str = "Prime" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn proposals (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: H256 > , :: subxt :: Error > { let entry = Proposals ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn proposal_of (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: dev_runtime :: Call > , :: subxt :: Error > { let entry = ProposalOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn proposal_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ProposalOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn voting (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_collective :: Votes < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > > , :: subxt :: Error > { let entry = Voting (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn voting_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Voting > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn proposal_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = ProposalCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn members (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = Members ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn prime (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = Prime ; self . client . storage () . fetch (& entry , hash) . await } } } } pub mod elections { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Vote { pub votes : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 } impl :: subxt :: Call for Vote { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "vote" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemoveVoter { } impl :: subxt :: Call for RemoveVoter { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "remove_voter" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SubmitCandidacy { # [codec (compact)] pub candidate_count : :: core :: primitive :: u32 } impl :: subxt :: Call for SubmitCandidacy { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "submit_candidacy" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RenounceCandidacy { pub renouncing : runtime_types :: pallet_elections_phragmen :: Renouncing } impl :: subxt :: Call for RenounceCandidacy { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "renounce_candidacy" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemoveMember { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub has_replacement : :: core :: primitive :: bool } impl :: subxt :: Call for RemoveMember { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "remove_member" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CleanDefunctVoters { pub num_voters : :: core :: primitive :: u32 , pub num_defunct : :: core :: primitive :: u32 } impl :: subxt :: Call for CleanDefunctVoters { const PALLET : & 'static str = "Elections" ; const FUNCTION : & 'static str = "clean_defunct_voters" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn vote (& self , votes : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Vote > { let call = Vote { votes , value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_voter (& self ,) -> :: subxt :: SubmittableExtrinsic < T , RemoveVoter > { let call = RemoveVoter { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn submit_candidacy (& self , candidate_count : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SubmitCandidacy > { let call = SubmitCandidacy { candidate_count , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn renounce_candidacy (& self , renouncing : runtime_types :: pallet_elections_phragmen :: Renouncing ,) -> :: subxt :: SubmittableExtrinsic < T , RenounceCandidacy > { let call = RenounceCandidacy { renouncing , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_member (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , has_replacement : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , RemoveMember > { let call = RemoveMember { who , has_replacement , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn clean_defunct_voters (& self , num_voters : :: core :: primitive :: u32 , num_defunct : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , CleanDefunctVoters > { let call = CleanDefunctVoters { num_voters , num_defunct , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_elections_phragmen :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NewTerm (pub :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) >) ; impl :: subxt :: Event for NewTerm { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "NewTerm" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct EmptyTerm { } impl :: subxt :: Event for EmptyTerm { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "EmptyTerm" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ElectionError { } impl :: subxt :: Event for ElectionError { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "ElectionError" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MemberKicked (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for MemberKicked { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "MemberKicked" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Renounced (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for Renounced { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "Renounced" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CandidateSlashed (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for CandidateSlashed { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "CandidateSlashed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SeatHolderSlashed (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for SeatHolderSlashed { const PALLET : & 'static str = "Elections" ; const EVENT : & 'static str = "SeatHolderSlashed" ; } } pub mod storage { use super :: runtime_types ; pub struct Members ; impl :: subxt :: StorageEntry for Members { const PALLET : & 'static str = "Elections" ; const STORAGE : & 'static str = "Members" ; type Value = :: std :: vec :: Vec < runtime_types :: pallet_elections_phragmen :: SeatHolder < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct RunnersUp ; impl :: subxt :: StorageEntry for RunnersUp { const PALLET : & 'static str = "Elections" ; const STORAGE : & 'static str = "RunnersUp" ; type Value = :: std :: vec :: Vec < runtime_types :: pallet_elections_phragmen :: SeatHolder < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Candidates ; impl :: subxt :: StorageEntry for Candidates { const PALLET : & 'static str = "Elections" ; const STORAGE : & 'static str = "Candidates" ; type Value = :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ElectionRounds ; impl :: subxt :: StorageEntry for ElectionRounds { const PALLET : & 'static str = "Elections" ; const STORAGE : & 'static str = "ElectionRounds" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Voting (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Voting { const PALLET : & 'static str = "Elections" ; const STORAGE : & 'static str = "Voting" ; type Value = runtime_types :: pallet_elections_phragmen :: Voter < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn members (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: pallet_elections_phragmen :: SeatHolder < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: Error > { let entry = Members ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn runners_up (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: pallet_elections_phragmen :: SeatHolder < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: Error > { let entry = RunnersUp ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn candidates (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > , :: subxt :: Error > { let entry = Candidates ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn election_rounds (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = ElectionRounds ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn voting (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: pallet_elections_phragmen :: Voter < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > , :: subxt :: Error > { let entry = Voting (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn voting_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Voting > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod technical_membership { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AddMember { pub who : :: subxt :: sp_core :: crypto :: AccountId32 } impl :: subxt :: Call for AddMember { const PALLET : & 'static str = "TechnicalMembership" ; const FUNCTION : & 'static str = "add_member" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemoveMember { pub who : :: subxt :: sp_core :: crypto :: AccountId32 } impl :: subxt :: Call for RemoveMember { const PALLET : & 'static str = "TechnicalMembership" ; const FUNCTION : & 'static str = "remove_member" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SwapMember { pub remove : :: subxt :: sp_core :: crypto :: AccountId32 , pub add : :: subxt :: sp_core :: crypto :: AccountId32 } impl :: subxt :: Call for SwapMember { const PALLET : & 'static str = "TechnicalMembership" ; const FUNCTION : & 'static str = "swap_member" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ResetMembers { pub members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > } impl :: subxt :: Call for ResetMembers { const PALLET : & 'static str = "TechnicalMembership" ; const FUNCTION : & 'static str = "reset_members" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ChangeKey { pub new : :: subxt :: sp_core :: crypto :: AccountId32 } impl :: subxt :: Call for ChangeKey { const PALLET : & 'static str = "TechnicalMembership" ; const FUNCTION : & 'static str = "change_key" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetPrime { pub who : :: subxt :: sp_core :: crypto :: AccountId32 } impl :: subxt :: Call for SetPrime { const PALLET : & 'static str = "TechnicalMembership" ; const FUNCTION : & 'static str = "set_prime" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ClearPrime { } impl :: subxt :: Call for ClearPrime { const PALLET : & 'static str = "TechnicalMembership" ; const FUNCTION : & 'static str = "clear_prime" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn add_member (& self , who : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: SubmittableExtrinsic < T , AddMember > { let call = AddMember { who , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_member (& self , who : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: SubmittableExtrinsic < T , RemoveMember > { let call = RemoveMember { who , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn swap_member (& self , remove : :: subxt :: sp_core :: crypto :: AccountId32 , add : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: SubmittableExtrinsic < T , SwapMember > { let call = SwapMember { remove , add , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn reset_members (& self , members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: SubmittableExtrinsic < T , ResetMembers > { let call = ResetMembers { members , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn change_key (& self , new : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: SubmittableExtrinsic < T , ChangeKey > { let call = ChangeKey { new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_prime (& self , who : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetPrime > { let call = SetPrime { who , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn clear_prime (& self ,) -> :: subxt :: SubmittableExtrinsic < T , ClearPrime > { let call = ClearPrime { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_membership :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MemberAdded { } impl :: subxt :: Event for MemberAdded { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "MemberAdded" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MemberRemoved { } impl :: subxt :: Event for MemberRemoved { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "MemberRemoved" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MembersSwapped { } impl :: subxt :: Event for MembersSwapped { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "MembersSwapped" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MembersReset { } impl :: subxt :: Event for MembersReset { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "MembersReset" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct KeyChanged { } impl :: subxt :: Event for KeyChanged { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "KeyChanged" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Dummy { } impl :: subxt :: Event for Dummy { const PALLET : & 'static str = "TechnicalMembership" ; const EVENT : & 'static str = "Dummy" ; } } pub mod storage { use super :: runtime_types ; pub struct Members ; impl :: subxt :: StorageEntry for Members { const PALLET : & 'static str = "TechnicalMembership" ; const STORAGE : & 'static str = "Members" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Prime ; impl :: subxt :: StorageEntry for Prime { const PALLET : & 'static str = "TechnicalMembership" ; const STORAGE : & 'static str = "Prime" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn members (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = Members ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn prime (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = Prime ; self . client . storage () . fetch (& entry , hash) . await } } } } pub mod treasury { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ProposeSpend { # [codec (compact)] pub value : :: core :: primitive :: u128 , pub beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > } impl :: subxt :: Call for ProposeSpend { const PALLET : & 'static str = "Treasury" ; const FUNCTION : & 'static str = "propose_spend" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RejectProposal { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 } impl :: subxt :: Call for RejectProposal { const PALLET : & 'static str = "Treasury" ; const FUNCTION : & 'static str = "reject_proposal" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ApproveProposal { # [codec (compact)] pub proposal_id : :: core :: primitive :: u32 } impl :: subxt :: Call for ApproveProposal { const PALLET : & 'static str = "Treasury" ; const FUNCTION : & 'static str = "approve_proposal" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn propose_spend (& self , value : :: core :: primitive :: u128 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: SubmittableExtrinsic < T , ProposeSpend > { let call = ProposeSpend { value , beneficiary , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn reject_proposal (& self , proposal_id : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , RejectProposal > { let call = RejectProposal { proposal_id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn approve_proposal (& self , proposal_id : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , ApproveProposal > { let call = ApproveProposal { proposal_id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_treasury :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Proposed (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Proposed { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Proposed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Spending (pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Spending { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Spending" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Awarded (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u128 , pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for Awarded { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Awarded" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Rejected (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Rejected { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Rejected" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Burnt (pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Burnt { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Burnt" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Rollover (pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Rollover { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Rollover" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Deposit (pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Deposit { const PALLET : & 'static str = "Treasury" ; const EVENT : & 'static str = "Deposit" ; } } pub mod storage { use super :: runtime_types ; pub struct ProposalCount ; impl :: subxt :: StorageEntry for ProposalCount { const PALLET : & 'static str = "Treasury" ; const STORAGE : & 'static str = "ProposalCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Proposals (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Proposals { const PALLET : & 'static str = "Treasury" ; const STORAGE : & 'static str = "Proposals" ; type Value = runtime_types :: pallet_treasury :: Proposal < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Approvals ; impl :: subxt :: StorageEntry for Approvals { const PALLET : & 'static str = "Treasury" ; const STORAGE : & 'static str = "Approvals" ; type Value = runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn proposal_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = ProposalCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn proposals (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_treasury :: Proposal < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 > > , :: subxt :: Error > { let entry = Proposals (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn proposals_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Proposals > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn approvals (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = Approvals ; self . client . storage () . fetch_or_default (& entry , hash) . await } } } } pub mod identity { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AddRegistrar { pub account : :: subxt :: sp_core :: crypto :: AccountId32 } impl :: subxt :: Call for AddRegistrar { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "add_registrar" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetIdentity { pub info : runtime_types :: pallet_identity :: types :: IdentityInfo } impl :: subxt :: Call for SetIdentity { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "set_identity" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetSubs { pub subs : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > } impl :: subxt :: Call for SetSubs { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "set_subs" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ClearIdentity { } impl :: subxt :: Call for ClearIdentity { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "clear_identity" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RequestJudgement { # [codec (compact)] pub reg_index : :: core :: primitive :: u32 , # [codec (compact)] pub max_fee : :: core :: primitive :: u128 } impl :: subxt :: Call for RequestJudgement { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "request_judgement" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CancelRequest { pub reg_index : :: core :: primitive :: u32 } impl :: subxt :: Call for CancelRequest { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "cancel_request" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetFee { # [codec (compact)] pub index : :: core :: primitive :: u32 , # [codec (compact)] pub fee : :: core :: primitive :: u128 } impl :: subxt :: Call for SetFee { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "set_fee" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetAccountId { # [codec (compact)] pub index : :: core :: primitive :: u32 , pub new : :: subxt :: sp_core :: crypto :: AccountId32 } impl :: subxt :: Call for SetAccountId { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "set_account_id" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetFields { # [codec (compact)] pub index : :: core :: primitive :: u32 , pub fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > } impl :: subxt :: Call for SetFields { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "set_fields" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ProvideJudgement { # [codec (compact)] pub reg_index : :: core :: primitive :: u32 , pub target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub judgement : runtime_types :: pallet_identity :: types :: Judgement < :: core :: primitive :: u128 > } impl :: subxt :: Call for ProvideJudgement { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "provide_judgement" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct KillIdentity { pub target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > } impl :: subxt :: Call for KillIdentity { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "kill_identity" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AddSub { pub sub : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub data : runtime_types :: pallet_identity :: types :: Data } impl :: subxt :: Call for AddSub { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "add_sub" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RenameSub { pub sub : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub data : runtime_types :: pallet_identity :: types :: Data } impl :: subxt :: Call for RenameSub { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "rename_sub" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemoveSub { pub sub : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > } impl :: subxt :: Call for RemoveSub { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "remove_sub" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct QuitSub { } impl :: subxt :: Call for QuitSub { const PALLET : & 'static str = "Identity" ; const FUNCTION : & 'static str = "quit_sub" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn add_registrar (& self , account : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: SubmittableExtrinsic < T , AddRegistrar > { let call = AddRegistrar { account , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_identity (& self , info : runtime_types :: pallet_identity :: types :: IdentityInfo ,) -> :: subxt :: SubmittableExtrinsic < T , SetIdentity > { let call = SetIdentity { info , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_subs (& self , subs : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > ,) -> :: subxt :: SubmittableExtrinsic < T , SetSubs > { let call = SetSubs { subs , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn clear_identity (& self ,) -> :: subxt :: SubmittableExtrinsic < T , ClearIdentity > { let call = ClearIdentity { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn request_judgement (& self , reg_index : :: core :: primitive :: u32 , max_fee : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , RequestJudgement > { let call = RequestJudgement { reg_index , max_fee , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn cancel_request (& self , reg_index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , CancelRequest > { let call = CancelRequest { reg_index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_fee (& self , index : :: core :: primitive :: u32 , fee : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , SetFee > { let call = SetFee { index , fee , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_account_id (& self , index : :: core :: primitive :: u32 , new : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetAccountId > { let call = SetAccountId { index , new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_fields (& self , index : :: core :: primitive :: u32 , fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > ,) -> :: subxt :: SubmittableExtrinsic < T , SetFields > { let call = SetFields { index , fields , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn provide_judgement (& self , reg_index : :: core :: primitive :: u32 , target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , judgement : runtime_types :: pallet_identity :: types :: Judgement < :: core :: primitive :: u128 > ,) -> :: subxt :: SubmittableExtrinsic < T , ProvideJudgement > { let call = ProvideJudgement { reg_index , target , judgement , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn kill_identity (& self , target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: SubmittableExtrinsic < T , KillIdentity > { let call = KillIdentity { target , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn add_sub (& self , sub : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , data : runtime_types :: pallet_identity :: types :: Data ,) -> :: subxt :: SubmittableExtrinsic < T , AddSub > { let call = AddSub { sub , data , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn rename_sub (& self , sub : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , data : runtime_types :: pallet_identity :: types :: Data ,) -> :: subxt :: SubmittableExtrinsic < T , RenameSub > { let call = RenameSub { sub , data , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_sub (& self , sub : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: SubmittableExtrinsic < T , RemoveSub > { let call = RemoveSub { sub , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn quit_sub (& self ,) -> :: subxt :: SubmittableExtrinsic < T , QuitSub > { let call = QuitSub { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_identity :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct IdentitySet (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for IdentitySet { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "IdentitySet" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct IdentityCleared (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for IdentityCleared { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "IdentityCleared" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct IdentityKilled (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for IdentityKilled { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "IdentityKilled" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct JudgementRequested (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for JudgementRequested { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "JudgementRequested" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct JudgementUnrequested (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for JudgementUnrequested { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "JudgementUnrequested" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct JudgementGiven (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for JudgementGiven { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "JudgementGiven" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RegistrarAdded (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for RegistrarAdded { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "RegistrarAdded" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SubIdentityAdded (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for SubIdentityAdded { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "SubIdentityAdded" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SubIdentityRemoved (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for SubIdentityRemoved { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "SubIdentityRemoved" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SubIdentityRevoked (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for SubIdentityRevoked { const PALLET : & 'static str = "Identity" ; const EVENT : & 'static str = "SubIdentityRevoked" ; } } pub mod storage { use super :: runtime_types ; pub struct IdentityOf (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for IdentityOf { const PALLET : & 'static str = "Identity" ; const STORAGE : & 'static str = "IdentityOf" ; type Value = runtime_types :: pallet_identity :: types :: Registration < :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct SuperOf (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for SuperOf { const PALLET : & 'static str = "Identity" ; const STORAGE : & 'static str = "SuperOf" ; type Value = (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct SubsOf (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for SubsOf { const PALLET : & 'static str = "Identity" ; const STORAGE : & 'static str = "SubsOf" ; type Value = (:: core :: primitive :: u128 , runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Registrars ; impl :: subxt :: StorageEntry for Registrars { const PALLET : & 'static str = "Identity" ; const STORAGE : & 'static str = "Registrars" ; type Value = runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < :: core :: option :: Option < runtime_types :: pallet_identity :: types :: RegistrarInfo < :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 > > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn identity_of (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_identity :: types :: Registration < :: core :: primitive :: u128 > > , :: subxt :: Error > { let entry = IdentityOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn identity_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , IdentityOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn super_of (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > , :: subxt :: Error > { let entry = SuperOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn super_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , SuperOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn subs_of (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < (:: core :: primitive :: u128 , runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) , :: subxt :: Error > { let entry = SubsOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn subs_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , SubsOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn registrars (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < :: core :: option :: Option < runtime_types :: pallet_identity :: types :: RegistrarInfo < :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 > > > , :: subxt :: Error > { let entry = Registrars ; self . client . storage () . fetch_or_default (& entry , hash) . await } } } } pub mod utility { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Batch { pub calls : :: std :: vec :: Vec < runtime_types :: dev_runtime :: Call > } impl :: subxt :: Call for Batch { const PALLET : & 'static str = "Utility" ; const FUNCTION : & 'static str = "batch" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AsDerivative { pub index : :: core :: primitive :: u16 , pub call : runtime_types :: dev_runtime :: Call } impl :: subxt :: Call for AsDerivative { const PALLET : & 'static str = "Utility" ; const FUNCTION : & 'static str = "as_derivative" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BatchAll { pub calls : :: std :: vec :: Vec < runtime_types :: dev_runtime :: Call > } impl :: subxt :: Call for BatchAll { const PALLET : & 'static str = "Utility" ; const FUNCTION : & 'static str = "batch_all" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn batch (& self , calls : :: std :: vec :: Vec < runtime_types :: dev_runtime :: Call > ,) -> :: subxt :: SubmittableExtrinsic < T , Batch > { let call = Batch { calls , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn as_derivative (& self , index : :: core :: primitive :: u16 , call : runtime_types :: dev_runtime :: Call ,) -> :: subxt :: SubmittableExtrinsic < T , AsDerivative > { let call = AsDerivative { index , call , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn batch_all (& self , calls : :: std :: vec :: Vec < runtime_types :: dev_runtime :: Call > ,) -> :: subxt :: SubmittableExtrinsic < T , BatchAll > { let call = BatchAll { calls , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_utility :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BatchInterrupted (pub :: core :: primitive :: u32 , pub runtime_types :: sp_runtime :: DispatchError) ; impl :: subxt :: Event for BatchInterrupted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchInterrupted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BatchCompleted { } impl :: subxt :: Event for BatchCompleted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "BatchCompleted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ItemCompleted { } impl :: subxt :: Event for ItemCompleted { const PALLET : & 'static str = "Utility" ; const EVENT : & 'static str = "ItemCompleted" ; } } } pub mod multisig { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AsMultiThreshold1 { pub other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , pub call : runtime_types :: dev_runtime :: Call } impl :: subxt :: Call for AsMultiThreshold1 { const PALLET : & 'static str = "Multisig" ; const FUNCTION : & 'static str = "as_multi_threshold1" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AsMulti { pub threshold : :: core :: primitive :: u16 , pub other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , pub maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , pub call : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub store_call : :: core :: primitive :: bool , pub max_weight : :: core :: primitive :: u64 } impl :: subxt :: Call for AsMulti { const PALLET : & 'static str = "Multisig" ; const FUNCTION : & 'static str = "as_multi" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ApproveAsMulti { pub threshold : :: core :: primitive :: u16 , pub other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , pub maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , pub call_hash : [:: core :: primitive :: u8 ; 32usize] , pub max_weight : :: core :: primitive :: u64 } impl :: subxt :: Call for ApproveAsMulti { const PALLET : & 'static str = "Multisig" ; const FUNCTION : & 'static str = "approve_as_multi" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CancelAsMulti { pub threshold : :: core :: primitive :: u16 , pub other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , pub timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub call_hash : [:: core :: primitive :: u8 ; 32usize] } impl :: subxt :: Call for CancelAsMulti { const PALLET : & 'static str = "Multisig" ; const FUNCTION : & 'static str = "cancel_as_multi" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn as_multi_threshold1 (& self , other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , call : runtime_types :: dev_runtime :: Call ,) -> :: subxt :: SubmittableExtrinsic < T , AsMultiThreshold1 > { let call = AsMultiThreshold1 { other_signatories , call , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn as_multi (& self , threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call : :: std :: vec :: Vec < :: core :: primitive :: u8 > , store_call : :: core :: primitive :: bool , max_weight : :: core :: primitive :: u64 ,) -> :: subxt :: SubmittableExtrinsic < T , AsMulti > { let call = AsMulti { threshold , other_signatories , maybe_timepoint , call , store_call , max_weight , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn approve_as_multi (& self , threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call_hash : [:: core :: primitive :: u8 ; 32usize] , max_weight : :: core :: primitive :: u64 ,) -> :: subxt :: SubmittableExtrinsic < T , ApproveAsMulti > { let call = ApproveAsMulti { threshold , other_signatories , maybe_timepoint , call_hash , max_weight , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn cancel_as_multi (& self , threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , call_hash : [:: core :: primitive :: u8 ; 32usize] ,) -> :: subxt :: SubmittableExtrinsic < T , CancelAsMulti > { let call = CancelAsMulti { threshold , other_signatories , timepoint , call_hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_multisig :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NewMultisig (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub [:: core :: primitive :: u8 ; 32usize]) ; impl :: subxt :: Event for NewMultisig { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "NewMultisig" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MultisigApproval (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub [:: core :: primitive :: u8 ; 32usize]) ; impl :: subxt :: Event for MultisigApproval { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigApproval" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MultisigExecuted (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub [:: core :: primitive :: u8 ; 32usize] , pub :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError >) ; impl :: subxt :: Event for MultisigExecuted { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigExecuted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MultisigCancelled (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub [:: core :: primitive :: u8 ; 32usize]) ; impl :: subxt :: Event for MultisigCancelled { const PALLET : & 'static str = "Multisig" ; const EVENT : & 'static str = "MultisigCancelled" ; } } pub mod storage { use super :: runtime_types ; pub struct Multisigs (:: subxt :: sp_core :: crypto :: AccountId32 , [:: core :: primitive :: u8 ; 32usize]) ; impl :: subxt :: StorageEntry for Multisigs { const PALLET : & 'static str = "Multisig" ; const STORAGE : & 'static str = "Multisigs" ; type Value = runtime_types :: pallet_multisig :: Multisig < :: core :: primitive :: u32 , :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct Calls (pub [:: core :: primitive :: u8 ; 32usize]) ; impl :: subxt :: StorageEntry for Calls { const PALLET : & 'static str = "Multisig" ; const STORAGE : & 'static str = "Calls" ; type Value = (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn multisigs (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , _1 : [:: core :: primitive :: u8 ; 32usize] , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_multisig :: Multisig < :: core :: primitive :: u32 , :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 > > , :: subxt :: Error > { let entry = Multisigs (_0 , _1) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn multisigs_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Multisigs > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn calls (& self , _0 : [:: core :: primitive :: u8 ; 32usize] , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > , :: subxt :: Error > { let entry = Calls (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn calls_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Calls > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod x_system { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ModifyPaused { pub pallet : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub call : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub should_paused : :: core :: primitive :: bool } impl :: subxt :: Call for ModifyPaused { const PALLET : & 'static str = "XSystem" ; const FUNCTION : & 'static str = "modify_paused" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ToggleBlacklist { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub should_blacklist : :: core :: primitive :: bool } impl :: subxt :: Call for ToggleBlacklist { const PALLET : & 'static str = "XSystem" ; const FUNCTION : & 'static str = "toggle_blacklist" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn modify_paused (& self , pallet : :: std :: vec :: Vec < :: core :: primitive :: u8 > , call : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , should_paused : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , ModifyPaused > { let call = ModifyPaused { pallet , call , should_paused , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn toggle_blacklist (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , should_blacklist : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , ToggleBlacklist > { let call = ToggleBlacklist { who , should_blacklist , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: xpallet_system :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Blacklisted (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for Blacklisted { const PALLET : & 'static str = "XSystem" ; const EVENT : & 'static str = "Blacklisted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Unblacklisted (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for Unblacklisted { const PALLET : & 'static str = "XSystem" ; const EVENT : & 'static str = "Unblacklisted" ; } } pub mod storage { use super :: runtime_types ; pub struct NetworkProps ; impl :: subxt :: StorageEntry for NetworkProps { const PALLET : & 'static str = "XSystem" ; const STORAGE : & 'static str = "NetworkProps" ; type Value = runtime_types :: xp_protocol :: network :: NetworkType ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Paused (pub :: std :: vec :: Vec < :: core :: primitive :: u8 >) ; impl :: subxt :: StorageEntry for Paused { const PALLET : & 'static str = "XSystem" ; const STORAGE : & 'static str = "Paused" ; type Value = :: std :: collections :: BTreeMap < :: std :: vec :: Vec < :: core :: primitive :: u8 > , () > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Blacklist (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Blacklist { const PALLET : & 'static str = "XSystem" ; const STORAGE : & 'static str = "Blacklist" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn network_props (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xp_protocol :: network :: NetworkType , :: subxt :: Error > { let entry = NetworkProps ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn paused (& self , _0 : :: std :: vec :: Vec < :: core :: primitive :: u8 > , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: collections :: BTreeMap < :: std :: vec :: Vec < :: core :: primitive :: u8 > , () > , :: subxt :: Error > { let entry = Paused (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn paused_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Paused > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn blacklist (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = Blacklist (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn blacklist_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Blacklist > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod x_assets_registrar { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Register { # [codec (compact)] pub asset_id : :: core :: primitive :: u32 , pub asset : runtime_types :: xpallet_assets_registrar :: types :: AssetInfo , pub is_online : :: core :: primitive :: bool , pub has_mining_rights : :: core :: primitive :: bool } impl :: subxt :: Call for Register { const PALLET : & 'static str = "XAssetsRegistrar" ; const FUNCTION : & 'static str = "register" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Deregister { # [codec (compact)] pub id : :: core :: primitive :: u32 } impl :: subxt :: Call for Deregister { const PALLET : & 'static str = "XAssetsRegistrar" ; const FUNCTION : & 'static str = "deregister" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Recover { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub has_mining_rights : :: core :: primitive :: bool } impl :: subxt :: Call for Recover { const PALLET : & 'static str = "XAssetsRegistrar" ; const FUNCTION : & 'static str = "recover" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct UpdateAssetInfo { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub token : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub token_name : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub desc : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > } impl :: subxt :: Call for UpdateAssetInfo { const PALLET : & 'static str = "XAssetsRegistrar" ; const FUNCTION : & 'static str = "update_asset_info" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn register (& self , asset_id : :: core :: primitive :: u32 , asset : runtime_types :: xpallet_assets_registrar :: types :: AssetInfo , is_online : :: core :: primitive :: bool , has_mining_rights : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , Register > { let call = Register { asset_id , asset , is_online , has_mining_rights , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn deregister (& self , id : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Deregister > { let call = Deregister { id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn recover (& self , id : :: core :: primitive :: u32 , has_mining_rights : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , Recover > { let call = Recover { id , has_mining_rights , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn update_asset_info (& self , id : :: core :: primitive :: u32 , token : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , token_name : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , desc : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ,) -> :: subxt :: SubmittableExtrinsic < T , UpdateAssetInfo > { let call = UpdateAssetInfo { id , token , token_name , desc , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: xpallet_assets_registrar :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Registered (pub :: core :: primitive :: u32 , pub :: core :: primitive :: bool) ; impl :: subxt :: Event for Registered { const PALLET : & 'static str = "XAssetsRegistrar" ; const EVENT : & 'static str = "Registered" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Recovered (pub :: core :: primitive :: u32 , pub :: core :: primitive :: bool) ; impl :: subxt :: Event for Recovered { const PALLET : & 'static str = "XAssetsRegistrar" ; const EVENT : & 'static str = "Recovered" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Deregistered (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for Deregistered { const PALLET : & 'static str = "XAssetsRegistrar" ; const EVENT : & 'static str = "Deregistered" ; } } pub mod storage { use super :: runtime_types ; pub struct AssetIdsOf (pub runtime_types :: xp_assets_registrar :: Chain) ; impl :: subxt :: StorageEntry for AssetIdsOf { const PALLET : & 'static str = "XAssetsRegistrar" ; const STORAGE : & 'static str = "AssetIdsOf" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct AssetInfoOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for AssetInfoOf { const PALLET : & 'static str = "XAssetsRegistrar" ; const STORAGE : & 'static str = "AssetInfoOf" ; type Value = runtime_types :: xpallet_assets_registrar :: types :: AssetInfo ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct AssetOnline (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for AssetOnline { const PALLET : & 'static str = "XAssetsRegistrar" ; const STORAGE : & 'static str = "AssetOnline" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct RegisteredAt (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for RegisteredAt { const PALLET : & 'static str = "XAssetsRegistrar" ; const STORAGE : & 'static str = "RegisteredAt" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn asset_ids_of (& self , _0 : runtime_types :: xp_assets_registrar :: Chain , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = AssetIdsOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn asset_ids_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AssetIdsOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn asset_info_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_assets_registrar :: types :: AssetInfo > , :: subxt :: Error > { let entry = AssetInfoOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn asset_info_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AssetInfoOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn asset_online (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = AssetOnline (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn asset_online_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AssetOnline > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn registered_at (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = RegisteredAt (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn registered_at_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , RegisteredAt > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod x_assets { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Transfer { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub id : :: core :: primitive :: u32 , # [codec (compact)] pub value : :: core :: primitive :: u128 } impl :: subxt :: Call for Transfer { const PALLET : & 'static str = "XAssets" ; const FUNCTION : & 'static str = "transfer" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceTransfer { pub transactor : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub id : :: core :: primitive :: u32 , # [codec (compact)] pub value : :: core :: primitive :: u128 } impl :: subxt :: Call for ForceTransfer { const PALLET : & 'static str = "XAssets" ; const FUNCTION : & 'static str = "force_transfer" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetBalance { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub id : :: core :: primitive :: u32 , pub balances : :: std :: collections :: BTreeMap < runtime_types :: xpallet_assets :: types :: AssetType , :: core :: primitive :: u128 > } impl :: subxt :: Call for SetBalance { const PALLET : & 'static str = "XAssets" ; const FUNCTION : & 'static str = "set_balance" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetAssetLimit { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub restrictions : runtime_types :: xpallet_assets :: types :: AssetRestrictions } impl :: subxt :: Call for SetAssetLimit { const PALLET : & 'static str = "XAssets" ; const FUNCTION : & 'static str = "set_asset_limit" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn transfer (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , id : :: core :: primitive :: u32 , value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Transfer > { let call = Transfer { dest , id , value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn force_transfer (& self , transactor : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , id : :: core :: primitive :: u32 , value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , ForceTransfer > { let call = ForceTransfer { transactor , dest , id , value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_balance (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , id : :: core :: primitive :: u32 , balances : :: std :: collections :: BTreeMap < runtime_types :: xpallet_assets :: types :: AssetType , :: core :: primitive :: u128 > ,) -> :: subxt :: SubmittableExtrinsic < T , SetBalance > { let call = SetBalance { who , id , balances , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_asset_limit (& self , id : :: core :: primitive :: u32 , restrictions : runtime_types :: xpallet_assets :: types :: AssetRestrictions ,) -> :: subxt :: SubmittableExtrinsic < T , SetAssetLimit > { let call = SetAssetLimit { id , restrictions , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: xpallet_assets :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Moved (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: xpallet_assets :: types :: AssetType , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: xpallet_assets :: types :: AssetType , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Moved { const PALLET : & 'static str = "XAssets" ; const EVENT : & 'static str = "Moved" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Issued (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Issued { const PALLET : & 'static str = "XAssets" ; const EVENT : & 'static str = "Issued" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Destroyed (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Destroyed { const PALLET : & 'static str = "XAssets" ; const EVENT : & 'static str = "Destroyed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BalanceSet (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: xpallet_assets :: types :: AssetType , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for BalanceSet { const PALLET : & 'static str = "XAssets" ; const EVENT : & 'static str = "BalanceSet" ; } } pub mod storage { use super :: runtime_types ; pub struct AssetRestrictionsOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for AssetRestrictionsOf { const PALLET : & 'static str = "XAssets" ; const STORAGE : & 'static str = "AssetRestrictionsOf" ; type Value = runtime_types :: xpallet_assets :: types :: AssetRestrictions ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct AssetBalance (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for AssetBalance { const PALLET : & 'static str = "XAssets" ; const STORAGE : & 'static str = "AssetBalance" ; type Value = :: std :: collections :: BTreeMap < runtime_types :: xpallet_assets :: types :: AssetType , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Locks (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Locks { const PALLET : & 'static str = "XAssets" ; const STORAGE : & 'static str = "Locks" ; type Value = :: std :: vec :: Vec < runtime_types :: xpallet_assets :: types :: BalanceLock < :: core :: primitive :: u128 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct TotalAssetBalance (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for TotalAssetBalance { const PALLET : & 'static str = "XAssets" ; const STORAGE : & 'static str = "TotalAssetBalance" ; type Value = :: std :: collections :: BTreeMap < runtime_types :: xpallet_assets :: types :: AssetType , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn asset_restrictions_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_assets :: types :: AssetRestrictions , :: subxt :: Error > { let entry = AssetRestrictionsOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn asset_restrictions_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AssetRestrictionsOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn asset_balance (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , _1 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: collections :: BTreeMap < runtime_types :: xpallet_assets :: types :: AssetType , :: core :: primitive :: u128 > , :: subxt :: Error > { let entry = AssetBalance (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn asset_balance_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AssetBalance > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn locks (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , _1 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: xpallet_assets :: types :: BalanceLock < :: core :: primitive :: u128 > > , :: subxt :: Error > { let entry = Locks (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn locks_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Locks > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn total_asset_balance (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: collections :: BTreeMap < runtime_types :: xpallet_assets :: types :: AssetType , :: core :: primitive :: u128 > , :: subxt :: Error > { let entry = TotalAssetBalance (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn total_asset_balance_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TotalAssetBalance > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod x_staking { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Bond { pub target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 } impl :: subxt :: Call for Bond { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "bond" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Rebond { pub from : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub to : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 } impl :: subxt :: Call for Rebond { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "rebond" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Unbond { pub target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub value : :: core :: primitive :: u128 } impl :: subxt :: Call for Unbond { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "unbond" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct UnlockUnbondedWithdrawal { pub target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub unbonded_index : :: core :: primitive :: u32 } impl :: subxt :: Call for UnlockUnbondedWithdrawal { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "unlock_unbonded_withdrawal" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Claim { pub target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > } impl :: subxt :: Call for Claim { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "claim" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Validate { } impl :: subxt :: Call for Validate { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "validate" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Chill { } impl :: subxt :: Call for Chill { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "chill" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Register { pub validator_nickname : :: std :: vec :: Vec < :: core :: primitive :: u8 > , # [codec (compact)] pub initial_bond : :: core :: primitive :: u128 } impl :: subxt :: Call for Register { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "register" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetValidatorCount { # [codec (compact)] pub new : :: core :: primitive :: u32 } impl :: subxt :: Call for SetValidatorCount { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "set_validator_count" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetMinimumValidatorCount { # [codec (compact)] pub new : :: core :: primitive :: u32 } impl :: subxt :: Call for SetMinimumValidatorCount { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "set_minimum_validator_count" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetBondingDuration { # [codec (compact)] pub new : :: core :: primitive :: u32 } impl :: subxt :: Call for SetBondingDuration { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "set_bonding_duration" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetValidatorBondingDuration { # [codec (compact)] pub new : :: core :: primitive :: u32 } impl :: subxt :: Call for SetValidatorBondingDuration { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "set_validator_bonding_duration" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetMinimumPenalty { # [codec (compact)] pub new : :: core :: primitive :: u128 } impl :: subxt :: Call for SetMinimumPenalty { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "set_minimum_penalty" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetSessionsPerEra { # [codec (compact)] pub new : :: core :: primitive :: u32 } impl :: subxt :: Call for SetSessionsPerEra { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "set_sessions_per_era" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetImmortals { pub new : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > } impl :: subxt :: Call for SetImmortals { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "set_immortals" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceUnlockBondedWithdrawal { pub who : :: subxt :: sp_core :: crypto :: AccountId32 } impl :: subxt :: Call for ForceUnlockBondedWithdrawal { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "force_unlock_bonded_withdrawal" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceResetStakingLock { pub accounts : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > } impl :: subxt :: Call for ForceResetStakingLock { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "force_reset_staking_lock" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceSetLock { pub new_locks : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > } impl :: subxt :: Call for ForceSetLock { const PALLET : & 'static str = "XStaking" ; const FUNCTION : & 'static str = "force_set_lock" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn bond (& self , target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Bond > { let call = Bond { target , value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn rebond (& self , from : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , to : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Rebond > { let call = Rebond { from , to , value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn unbond (& self , target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Unbond > { let call = Unbond { target , value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn unlock_unbonded_withdrawal (& self , target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , unbonded_index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , UnlockUnbondedWithdrawal > { let call = UnlockUnbondedWithdrawal { target , unbonded_index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn claim (& self , target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: SubmittableExtrinsic < T , Claim > { let call = Claim { target , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn validate (& self ,) -> :: subxt :: SubmittableExtrinsic < T , Validate > { let call = Validate { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn chill (& self ,) -> :: subxt :: SubmittableExtrinsic < T , Chill > { let call = Chill { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn register (& self , validator_nickname : :: std :: vec :: Vec < :: core :: primitive :: u8 > , initial_bond : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Register > { let call = Register { validator_nickname , initial_bond , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_validator_count (& self , new : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetValidatorCount > { let call = SetValidatorCount { new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_minimum_validator_count (& self , new : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetMinimumValidatorCount > { let call = SetMinimumValidatorCount { new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_bonding_duration (& self , new : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetBondingDuration > { let call = SetBondingDuration { new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_validator_bonding_duration (& self , new : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetValidatorBondingDuration > { let call = SetValidatorBondingDuration { new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_minimum_penalty (& self , new : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , SetMinimumPenalty > { let call = SetMinimumPenalty { new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_sessions_per_era (& self , new : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetSessionsPerEra > { let call = SetSessionsPerEra { new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_immortals (& self , new : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: SubmittableExtrinsic < T , SetImmortals > { let call = SetImmortals { new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn force_unlock_bonded_withdrawal (& self , who : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: SubmittableExtrinsic < T , ForceUnlockBondedWithdrawal > { let call = ForceUnlockBondedWithdrawal { who , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn force_reset_staking_lock (& self , accounts : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: SubmittableExtrinsic < T , ForceResetStakingLock > { let call = ForceResetStakingLock { accounts , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn force_set_lock (& self , new_locks : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > ,) -> :: subxt :: SubmittableExtrinsic < T , ForceSetLock > { let call = ForceSetLock { new_locks , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: xpallet_mining_staking :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Minted (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Minted { const PALLET : & 'static str = "XStaking" ; const EVENT : & 'static str = "Minted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Slashed (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Slashed { const PALLET : & 'static str = "XStaking" ; const EVENT : & 'static str = "Slashed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Bonded (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Bonded { const PALLET : & 'static str = "XStaking" ; const EVENT : & 'static str = "Bonded" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Rebonded (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Rebonded { const PALLET : & 'static str = "XStaking" ; const EVENT : & 'static str = "Rebonded" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Unbonded (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Unbonded { const PALLET : & 'static str = "XStaking" ; const EVENT : & 'static str = "Unbonded" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Claimed (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Claimed { const PALLET : & 'static str = "XStaking" ; const EVENT : & 'static str = "Claimed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Withdrawn (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Withdrawn { const PALLET : & 'static str = "XStaking" ; const EVENT : & 'static str = "Withdrawn" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceChilled (pub :: core :: primitive :: u32 , pub :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 >) ; impl :: subxt :: Event for ForceChilled { const PALLET : & 'static str = "XStaking" ; const EVENT : & 'static str = "ForceChilled" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceAllWithdrawn (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for ForceAllWithdrawn { const PALLET : & 'static str = "XStaking" ; const EVENT : & 'static str = "ForceAllWithdrawn" ; } } pub mod storage { use super :: runtime_types ; pub struct ValidatorCount ; impl :: subxt :: StorageEntry for ValidatorCount { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "ValidatorCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MinimumValidatorCount ; impl :: subxt :: StorageEntry for MinimumValidatorCount { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "MinimumValidatorCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MaximumValidatorCount ; impl :: subxt :: StorageEntry for MaximumValidatorCount { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "MaximumValidatorCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ValidatorCandidateRequirement ; impl :: subxt :: StorageEntry for ValidatorCandidateRequirement { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "ValidatorCandidateRequirement" ; type Value = runtime_types :: xpallet_mining_staking :: types :: BondRequirement < :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SessionsPerEra ; impl :: subxt :: StorageEntry for SessionsPerEra { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "SessionsPerEra" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct BondingDuration ; impl :: subxt :: StorageEntry for BondingDuration { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "BondingDuration" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ValidatorBondingDuration ; impl :: subxt :: StorageEntry for ValidatorBondingDuration { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "ValidatorBondingDuration" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MaximumUnbondedChunkSize ; impl :: subxt :: StorageEntry for MaximumUnbondedChunkSize { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "MaximumUnbondedChunkSize" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ValidatorFor (pub :: std :: vec :: Vec < :: core :: primitive :: u8 >) ; impl :: subxt :: StorageEntry for ValidatorFor { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "ValidatorFor" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct UpperBoundFactorOfAcceptableVotes ; impl :: subxt :: StorageEntry for UpperBoundFactorOfAcceptableVotes { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "UpperBoundFactorOfAcceptableVotes" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct GlobalDistributionRatio ; impl :: subxt :: StorageEntry for GlobalDistributionRatio { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "GlobalDistributionRatio" ; type Value = runtime_types :: xpallet_mining_staking :: types :: GlobalDistribution ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MiningDistributionRatio ; impl :: subxt :: StorageEntry for MiningDistributionRatio { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "MiningDistributionRatio" ; type Value = runtime_types :: xpallet_mining_staking :: types :: MiningDistribution ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Validators (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Validators { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "Validators" ; type Value = runtime_types :: xpallet_mining_staking :: types :: ValidatorProfile < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ValidatorLedgers (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for ValidatorLedgers { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "ValidatorLedgers" ; type Value = runtime_types :: xpallet_mining_staking :: types :: ValidatorLedger < :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Nominations (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Nominations { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "Nominations" ; type Value = runtime_types :: xpallet_mining_staking :: types :: NominatorLedger < :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct LastRebondOf (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for LastRebondOf { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "LastRebondOf" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Locks (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Locks { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "Locks" ; type Value = :: std :: collections :: BTreeMap < runtime_types :: xpallet_mining_staking :: types :: LockedType , :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct ForceEra ; impl :: subxt :: StorageEntry for ForceEra { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "ForceEra" ; type Value = runtime_types :: xpallet_mining_staking :: types :: Forcing ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct CurrentEra ; impl :: subxt :: StorageEntry for CurrentEra { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "CurrentEra" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ActiveEra ; impl :: subxt :: StorageEntry for ActiveEra { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "ActiveEra" ; type Value = runtime_types :: xpallet_mining_staking :: types :: ActiveEraInfo ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ErasStartSessionIndex (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ErasStartSessionIndex { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "ErasStartSessionIndex" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct IsCurrentSessionFinal ; impl :: subxt :: StorageEntry for IsCurrentSessionFinal { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "IsCurrentSessionFinal" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct SessionOffenders ; impl :: subxt :: StorageEntry for SessionOffenders { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "SessionOffenders" ; type Value = :: std :: collections :: BTreeMap < :: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: sp_arithmetic :: per_things :: Perbill > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MinimumPenalty ; impl :: subxt :: StorageEntry for MinimumPenalty { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "MinimumPenalty" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Immortals ; impl :: subxt :: StorageEntry for Immortals { const PALLET : & 'static str = "XStaking" ; const STORAGE : & 'static str = "Immortals" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn validator_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = ValidatorCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn minimum_validator_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = MinimumValidatorCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn maximum_validator_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = MaximumValidatorCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn validator_candidate_requirement (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_mining_staking :: types :: BondRequirement < :: core :: primitive :: u128 > , :: subxt :: Error > { let entry = ValidatorCandidateRequirement ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn sessions_per_era (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = SessionsPerEra ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn bonding_duration (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = BondingDuration ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn validator_bonding_duration (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = ValidatorBondingDuration ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn maximum_unbonded_chunk_size (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = MaximumUnbondedChunkSize ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn validator_for (& self , _0 : :: std :: vec :: Vec < :: core :: primitive :: u8 > , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = ValidatorFor (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn validator_for_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ValidatorFor > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn upper_bound_factor_of_acceptable_votes (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = UpperBoundFactorOfAcceptableVotes ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn global_distribution_ratio (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_mining_staking :: types :: GlobalDistribution , :: subxt :: Error > { let entry = GlobalDistributionRatio ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn mining_distribution_ratio (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_mining_staking :: types :: MiningDistribution , :: subxt :: Error > { let entry = MiningDistributionRatio ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn validators (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_mining_staking :: types :: ValidatorProfile < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = Validators (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn validators_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Validators > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn validator_ledgers (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_mining_staking :: types :: ValidatorLedger < :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = ValidatorLedgers (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn validator_ledgers_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ValidatorLedgers > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn nominations (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , _1 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_mining_staking :: types :: NominatorLedger < :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = Nominations (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn nominations_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Nominations > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn last_rebond_of (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = LastRebondOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn last_rebond_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , LastRebondOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn locks (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: collections :: BTreeMap < runtime_types :: xpallet_mining_staking :: types :: LockedType , :: core :: primitive :: u128 > , :: subxt :: Error > { let entry = Locks (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn locks_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Locks > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn force_era (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_mining_staking :: types :: Forcing , :: subxt :: Error > { let entry = ForceEra ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn current_era (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = CurrentEra ; self . client . storage () . fetch (& entry , hash) . await } pub async fn active_era (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_mining_staking :: types :: ActiveEraInfo > , :: subxt :: Error > { let entry = ActiveEra ; self . client . storage () . fetch (& entry , hash) . await } pub async fn eras_start_session_index (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = ErasStartSessionIndex (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn eras_start_session_index_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ErasStartSessionIndex > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn is_current_session_final (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = IsCurrentSessionFinal ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn session_offenders (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: std :: collections :: BTreeMap < :: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: sp_arithmetic :: per_things :: Perbill > > , :: subxt :: Error > { let entry = SessionOffenders ; self . client . storage () . fetch (& entry , hash) . await } pub async fn minimum_penalty (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: Error > { let entry = MinimumPenalty ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn immortals (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > > , :: subxt :: Error > { let entry = Immortals ; self . client . storage () . fetch (& entry , hash) . await } } } } pub mod x_mining_asset { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Claim { # [codec (compact)] pub target : :: core :: primitive :: u32 } impl :: subxt :: Call for Claim { const PALLET : & 'static str = "XMiningAsset" ; const FUNCTION : & 'static str = "claim" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetClaimStakingRequirement { # [codec (compact)] pub asset_id : :: core :: primitive :: u32 , # [codec (compact)] pub new : :: core :: primitive :: u32 } impl :: subxt :: Call for SetClaimStakingRequirement { const PALLET : & 'static str = "XMiningAsset" ; const FUNCTION : & 'static str = "set_claim_staking_requirement" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetClaimFrequencyLimit { # [codec (compact)] pub asset_id : :: core :: primitive :: u32 , # [codec (compact)] pub new : :: core :: primitive :: u32 } impl :: subxt :: Call for SetClaimFrequencyLimit { const PALLET : & 'static str = "XMiningAsset" ; const FUNCTION : & 'static str = "set_claim_frequency_limit" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetAssetPower { # [codec (compact)] pub asset_id : :: core :: primitive :: u32 , # [codec (compact)] pub new : :: core :: primitive :: u32 } impl :: subxt :: Call for SetAssetPower { const PALLET : & 'static str = "XMiningAsset" ; const FUNCTION : & 'static str = "set_asset_power" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn claim (& self , target : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , Claim > { let call = Claim { target , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_claim_staking_requirement (& self , asset_id : :: core :: primitive :: u32 , new : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetClaimStakingRequirement > { let call = SetClaimStakingRequirement { asset_id , new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_claim_frequency_limit (& self , asset_id : :: core :: primitive :: u32 , new : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetClaimFrequencyLimit > { let call = SetClaimFrequencyLimit { asset_id , new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_asset_power (& self , asset_id : :: core :: primitive :: u32 , new : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetAssetPower > { let call = SetAssetPower { asset_id , new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: xpallet_mining_asset :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Claimed (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Claimed { const PALLET : & 'static str = "XMiningAsset" ; const EVENT : & 'static str = "Claimed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Minted (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Minted { const PALLET : & 'static str = "XMiningAsset" ; const EVENT : & 'static str = "Minted" ; } } pub mod storage { use super :: runtime_types ; pub struct DepositReward ; impl :: subxt :: StorageEntry for DepositReward { const PALLET : & 'static str = "XMiningAsset" ; const STORAGE : & 'static str = "DepositReward" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ClaimRestrictionOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for ClaimRestrictionOf { const PALLET : & 'static str = "XMiningAsset" ; const STORAGE : & 'static str = "ClaimRestrictionOf" ; type Value = runtime_types :: xpallet_mining_asset :: types :: ClaimRestriction < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct MiningPrevilegedAssets ; impl :: subxt :: StorageEntry for MiningPrevilegedAssets { const PALLET : & 'static str = "XMiningAsset" ; const STORAGE : & 'static str = "MiningPrevilegedAssets" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct AssetLedgers (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for AssetLedgers { const PALLET : & 'static str = "XMiningAsset" ; const STORAGE : & 'static str = "AssetLedgers" ; type Value = runtime_types :: xpallet_mining_asset :: types :: AssetLedger < :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct MinerLedgers (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for MinerLedgers { const PALLET : & 'static str = "XMiningAsset" ; const STORAGE : & 'static str = "MinerLedgers" ; type Value = runtime_types :: xpallet_mining_asset :: types :: MinerLedger < :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct FixedAssetPowerOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for FixedAssetPowerOf { const PALLET : & 'static str = "XMiningAsset" ; const STORAGE : & 'static str = "FixedAssetPowerOf" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn deposit_reward (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: Error > { let entry = DepositReward ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn claim_restriction_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_mining_asset :: types :: ClaimRestriction < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = ClaimRestrictionOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn claim_restriction_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ClaimRestrictionOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn mining_previleged_assets (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = MiningPrevilegedAssets ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn asset_ledgers (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_mining_asset :: types :: AssetLedger < :: core :: primitive :: u128 , :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = AssetLedgers (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn asset_ledgers_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AssetLedgers > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn miner_ledgers (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , _1 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_mining_asset :: types :: MinerLedger < :: core :: primitive :: u128 , :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = MinerLedgers (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn miner_ledgers_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , MinerLedgers > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn fixed_asset_power_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = FixedAssetPowerOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn fixed_asset_power_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , FixedAssetPowerOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod x_gateway_records { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RootDeposit { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub asset_id : :: core :: primitive :: u32 , # [codec (compact)] pub balance : :: core :: primitive :: u128 } impl :: subxt :: Call for RootDeposit { const PALLET : & 'static str = "XGatewayRecords" ; const FUNCTION : & 'static str = "root_deposit" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RootWithdraw { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub asset_id : :: core :: primitive :: u32 , # [codec (compact)] pub balance : :: core :: primitive :: u128 , pub addr : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub memo : runtime_types :: xp_runtime :: Memo } impl :: subxt :: Call for RootWithdraw { const PALLET : & 'static str = "XGatewayRecords" ; const FUNCTION : & 'static str = "root_withdraw" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetWithdrawalState { # [codec (compact)] pub withdrawal_id : :: core :: primitive :: u32 , pub state : runtime_types :: xpallet_gateway_records :: types :: WithdrawalState } impl :: subxt :: Call for SetWithdrawalState { const PALLET : & 'static str = "XGatewayRecords" ; const FUNCTION : & 'static str = "set_withdrawal_state" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetWithdrawalStateList { pub item : :: std :: vec :: Vec < (:: core :: primitive :: u32 , runtime_types :: xpallet_gateway_records :: types :: WithdrawalState ,) > } impl :: subxt :: Call for SetWithdrawalStateList { const PALLET : & 'static str = "XGatewayRecords" ; const FUNCTION : & 'static str = "set_withdrawal_state_list" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn root_deposit (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , asset_id : :: core :: primitive :: u32 , balance : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , RootDeposit > { let call = RootDeposit { who , asset_id , balance , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn root_withdraw (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , asset_id : :: core :: primitive :: u32 , balance : :: core :: primitive :: u128 , addr : :: std :: vec :: Vec < :: core :: primitive :: u8 > , memo : runtime_types :: xp_runtime :: Memo ,) -> :: subxt :: SubmittableExtrinsic < T , RootWithdraw > { let call = RootWithdraw { who , asset_id , balance , addr , memo , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_withdrawal_state (& self , withdrawal_id : :: core :: primitive :: u32 , state : runtime_types :: xpallet_gateway_records :: types :: WithdrawalState ,) -> :: subxt :: SubmittableExtrinsic < T , SetWithdrawalState > { let call = SetWithdrawalState { withdrawal_id , state , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_withdrawal_state_list (& self , item : :: std :: vec :: Vec < (:: core :: primitive :: u32 , runtime_types :: xpallet_gateway_records :: types :: WithdrawalState ,) > ,) -> :: subxt :: SubmittableExtrinsic < T , SetWithdrawalStateList > { let call = SetWithdrawalStateList { item , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: xpallet_gateway_records :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Deposited (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Deposited { const PALLET : & 'static str = "XGatewayRecords" ; const EVENT : & 'static str = "Deposited" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalCreated (pub :: core :: primitive :: u32 , pub runtime_types :: xpallet_gateway_records :: types :: WithdrawalRecord < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 >) ; impl :: subxt :: Event for WithdrawalCreated { const PALLET : & 'static str = "XGatewayRecords" ; const EVENT : & 'static str = "WithdrawalCreated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalProcessed (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for WithdrawalProcessed { const PALLET : & 'static str = "XGatewayRecords" ; const EVENT : & 'static str = "WithdrawalProcessed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalRecovered (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for WithdrawalRecovered { const PALLET : & 'static str = "XGatewayRecords" ; const EVENT : & 'static str = "WithdrawalRecovered" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalCanceled (pub :: core :: primitive :: u32 , pub runtime_types :: xpallet_gateway_records :: types :: WithdrawalState) ; impl :: subxt :: Event for WithdrawalCanceled { const PALLET : & 'static str = "XGatewayRecords" ; const EVENT : & 'static str = "WithdrawalCanceled" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalFinished (pub :: core :: primitive :: u32 , pub runtime_types :: xpallet_gateway_records :: types :: WithdrawalState) ; impl :: subxt :: Event for WithdrawalFinished { const PALLET : & 'static str = "XGatewayRecords" ; const EVENT : & 'static str = "WithdrawalFinished" ; } } pub mod storage { use super :: runtime_types ; pub struct NextWithdrawalRecordId ; impl :: subxt :: StorageEntry for NextWithdrawalRecordId { const PALLET : & 'static str = "XGatewayRecords" ; const STORAGE : & 'static str = "NextWithdrawalRecordId" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct PendingWithdrawals (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for PendingWithdrawals { const PALLET : & 'static str = "XGatewayRecords" ; const STORAGE : & 'static str = "PendingWithdrawals" ; type Value = runtime_types :: xpallet_gateway_records :: types :: WithdrawalRecord < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct WithdrawalStateOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for WithdrawalStateOf { const PALLET : & 'static str = "XGatewayRecords" ; const STORAGE : & 'static str = "WithdrawalStateOf" ; type Value = runtime_types :: xpallet_gateway_records :: types :: WithdrawalState ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn next_withdrawal_record_id (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = NextWithdrawalRecordId ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn pending_withdrawals (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_gateway_records :: types :: WithdrawalRecord < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: Error > { let entry = PendingWithdrawals (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn pending_withdrawals_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , PendingWithdrawals > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn withdrawal_state_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_gateway_records :: types :: WithdrawalState > , :: subxt :: Error > { let entry = WithdrawalStateOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn withdrawal_state_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , WithdrawalStateOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod x_gateway_common { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Withdraw { # [codec (compact)] pub asset_id : :: core :: primitive :: u32 , # [codec (compact)] pub value : :: core :: primitive :: u128 , pub addr : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub ext : runtime_types :: xp_runtime :: Memo } impl :: subxt :: Call for Withdraw { const PALLET : & 'static str = "XGatewayCommon" ; const FUNCTION : & 'static str = "withdraw" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CancelWithdrawal { pub id : :: core :: primitive :: u32 } impl :: subxt :: Call for CancelWithdrawal { const PALLET : & 'static str = "XGatewayCommon" ; const FUNCTION : & 'static str = "cancel_withdrawal" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetupTrustee { pub chain : runtime_types :: xp_assets_registrar :: Chain , pub about : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub hot_entity : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub cold_entity : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for SetupTrustee { const PALLET : & 'static str = "XGatewayCommon" ; const FUNCTION : & 'static str = "setup_trustee" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TransitionTrusteeSession { pub chain : runtime_types :: xp_assets_registrar :: Chain , pub new_trustees : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > } impl :: subxt :: Call for TransitionTrusteeSession { const PALLET : & 'static str = "XGatewayCommon" ; const FUNCTION : & 'static str = "transition_trustee_session" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetWithdrawalState { # [codec (compact)] pub id : :: core :: primitive :: u32 , pub state : runtime_types :: xpallet_gateway_records :: types :: WithdrawalState } impl :: subxt :: Call for SetWithdrawalState { const PALLET : & 'static str = "XGatewayCommon" ; const FUNCTION : & 'static str = "set_withdrawal_state" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetTrusteeInfoConfig { pub chain : runtime_types :: xp_assets_registrar :: Chain , pub config : runtime_types :: xpallet_gateway_common :: types :: TrusteeInfoConfig } impl :: subxt :: Call for SetTrusteeInfoConfig { const PALLET : & 'static str = "XGatewayCommon" ; const FUNCTION : & 'static str = "set_trustee_info_config" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceSetReferralBinding { pub chain : runtime_types :: xp_assets_registrar :: Chain , pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub referral : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > } impl :: subxt :: Call for ForceSetReferralBinding { const PALLET : & 'static str = "XGatewayCommon" ; const FUNCTION : & 'static str = "force_set_referral_binding" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn withdraw (& self , asset_id : :: core :: primitive :: u32 , value : :: core :: primitive :: u128 , addr : :: std :: vec :: Vec < :: core :: primitive :: u8 > , ext : runtime_types :: xp_runtime :: Memo ,) -> :: subxt :: SubmittableExtrinsic < T , Withdraw > { let call = Withdraw { asset_id , value , addr , ext , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn cancel_withdrawal (& self , id : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , CancelWithdrawal > { let call = CancelWithdrawal { id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn setup_trustee (& self , chain : runtime_types :: xp_assets_registrar :: Chain , about : :: std :: vec :: Vec < :: core :: primitive :: u8 > , hot_entity : :: std :: vec :: Vec < :: core :: primitive :: u8 > , cold_entity : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , SetupTrustee > { let call = SetupTrustee { chain , about , hot_entity , cold_entity , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn transition_trustee_session (& self , chain : runtime_types :: xp_assets_registrar :: Chain , new_trustees : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: SubmittableExtrinsic < T , TransitionTrusteeSession > { let call = TransitionTrusteeSession { chain , new_trustees , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_withdrawal_state (& self , id : :: core :: primitive :: u32 , state : runtime_types :: xpallet_gateway_records :: types :: WithdrawalState ,) -> :: subxt :: SubmittableExtrinsic < T , SetWithdrawalState > { let call = SetWithdrawalState { id , state , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_trustee_info_config (& self , chain : runtime_types :: xp_assets_registrar :: Chain , config : runtime_types :: xpallet_gateway_common :: types :: TrusteeInfoConfig ,) -> :: subxt :: SubmittableExtrinsic < T , SetTrusteeInfoConfig > { let call = SetTrusteeInfoConfig { chain , config , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn force_set_referral_binding (& self , chain : runtime_types :: xp_assets_registrar :: Chain , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , referral : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: SubmittableExtrinsic < T , ForceSetReferralBinding > { let call = ForceSetReferralBinding { chain , who , referral , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: xpallet_gateway_common :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetTrusteeProps (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: xp_assets_registrar :: Chain , pub runtime_types :: xpallet_gateway_common :: types :: GenericTrusteeIntentionProps) ; impl :: subxt :: Event for SetTrusteeProps { const PALLET : & 'static str = "XGatewayCommon" ; const EVENT : & 'static str = "SetTrusteeProps" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ReferralBinded (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: xp_assets_registrar :: Chain , pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for ReferralBinded { const PALLET : & 'static str = "XGatewayCommon" ; const EVENT : & 'static str = "ReferralBinded" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TrusteeSetChanged (pub runtime_types :: xp_assets_registrar :: Chain , pub :: core :: primitive :: u32 , pub runtime_types :: xpallet_gateway_common :: types :: GenericTrusteeSessionInfo < :: subxt :: sp_core :: crypto :: AccountId32 >) ; impl :: subxt :: Event for TrusteeSetChanged { const PALLET : & 'static str = "XGatewayCommon" ; const EVENT : & 'static str = "TrusteeSetChanged" ; } } pub mod storage { use super :: runtime_types ; pub struct TrusteeMultiSigAddr (pub runtime_types :: xp_assets_registrar :: Chain) ; impl :: subxt :: StorageEntry for TrusteeMultiSigAddr { const PALLET : & 'static str = "XGatewayCommon" ; const STORAGE : & 'static str = "TrusteeMultiSigAddr" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct TrusteeInfoConfigOf (pub runtime_types :: xp_assets_registrar :: Chain) ; impl :: subxt :: StorageEntry for TrusteeInfoConfigOf { const PALLET : & 'static str = "XGatewayCommon" ; const STORAGE : & 'static str = "TrusteeInfoConfigOf" ; type Value = runtime_types :: xpallet_gateway_common :: types :: TrusteeInfoConfig ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct TrusteeSessionInfoLen (pub runtime_types :: xp_assets_registrar :: Chain) ; impl :: subxt :: StorageEntry for TrusteeSessionInfoLen { const PALLET : & 'static str = "XGatewayCommon" ; const STORAGE : & 'static str = "TrusteeSessionInfoLen" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct TrusteeSessionInfoOf (runtime_types :: xp_assets_registrar :: Chain , :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for TrusteeSessionInfoOf { const PALLET : & 'static str = "XGatewayCommon" ; const STORAGE : & 'static str = "TrusteeSessionInfoOf" ; type Value = runtime_types :: xpallet_gateway_common :: types :: GenericTrusteeSessionInfo < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct TrusteeIntentionPropertiesOf (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: xp_assets_registrar :: Chain) ; impl :: subxt :: StorageEntry for TrusteeIntentionPropertiesOf { const PALLET : & 'static str = "XGatewayCommon" ; const STORAGE : & 'static str = "TrusteeIntentionPropertiesOf" ; type Value = runtime_types :: xpallet_gateway_common :: types :: GenericTrusteeIntentionProps ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct AddressBindingOf (runtime_types :: xp_assets_registrar :: Chain , :: std :: vec :: Vec < :: core :: primitive :: u8 >) ; impl :: subxt :: StorageEntry for AddressBindingOf { const PALLET : & 'static str = "XGatewayCommon" ; const STORAGE : & 'static str = "AddressBindingOf" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct BoundAddressOf (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: xp_assets_registrar :: Chain) ; impl :: subxt :: StorageEntry for BoundAddressOf { const PALLET : & 'static str = "XGatewayCommon" ; const STORAGE : & 'static str = "BoundAddressOf" ; type Value = :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct ReferralBindingOf (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: xp_assets_registrar :: Chain) ; impl :: subxt :: StorageEntry for ReferralBindingOf { const PALLET : & 'static str = "XGatewayCommon" ; const STORAGE : & 'static str = "ReferralBindingOf" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn trustee_multi_sig_addr (& self , _0 : runtime_types :: xp_assets_registrar :: Chain , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: Error > { let entry = TrusteeMultiSigAddr (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn trustee_multi_sig_addr_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TrusteeMultiSigAddr > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn trustee_info_config_of (& self , _0 : runtime_types :: xp_assets_registrar :: Chain , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_gateway_common :: types :: TrusteeInfoConfig , :: subxt :: Error > { let entry = TrusteeInfoConfigOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn trustee_info_config_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TrusteeInfoConfigOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn trustee_session_info_len (& self , _0 : runtime_types :: xp_assets_registrar :: Chain , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = TrusteeSessionInfoLen (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn trustee_session_info_len_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TrusteeSessionInfoLen > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn trustee_session_info_of (& self , _0 : runtime_types :: xp_assets_registrar :: Chain , _1 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_gateway_common :: types :: GenericTrusteeSessionInfo < :: subxt :: sp_core :: crypto :: AccountId32 > > , :: subxt :: Error > { let entry = TrusteeSessionInfoOf (_0 , _1) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn trustee_session_info_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TrusteeSessionInfoOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn trustee_intention_properties_of (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , _1 : runtime_types :: xp_assets_registrar :: Chain , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_gateway_common :: types :: GenericTrusteeIntentionProps > , :: subxt :: Error > { let entry = TrusteeIntentionPropertiesOf (_0 , _1) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn trustee_intention_properties_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TrusteeIntentionPropertiesOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn address_binding_of (& self , _0 : runtime_types :: xp_assets_registrar :: Chain , _1 : :: std :: vec :: Vec < :: core :: primitive :: u8 > , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = AddressBindingOf (_0 , _1) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn address_binding_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , AddressBindingOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn bound_address_of (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , _1 : runtime_types :: xp_assets_registrar :: Chain , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: subxt :: Error > { let entry = BoundAddressOf (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn bound_address_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , BoundAddressOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn referral_binding_of (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , _1 : runtime_types :: xp_assets_registrar :: Chain , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , :: subxt :: Error > { let entry = ReferralBindingOf (_0 , _1) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn referral_binding_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , ReferralBindingOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod x_gateway_bitcoin { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PushHeader { pub header : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for PushHeader { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "push_header" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PushTransaction { pub raw_tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub relayed_info : runtime_types :: xpallet_gateway_bitcoin :: types :: BtcRelayedTxInfo , pub prev_tx : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > } impl :: subxt :: Call for PushTransaction { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "push_transaction" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CreateWithdrawTx { pub withdrawal_id_list : :: std :: vec :: Vec < :: core :: primitive :: u32 > , pub tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for CreateWithdrawTx { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "create_withdraw_tx" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CreateTaprootWithdrawTx { pub withdrawal_id_list : :: std :: vec :: Vec < :: core :: primitive :: u32 > , pub tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub spent_outputs : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for CreateTaprootWithdrawTx { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "create_taproot_withdraw_tx" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SignWithdrawTx { pub tx : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > } impl :: subxt :: Call for SignWithdrawTx { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "sign_withdraw_tx" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetBestIndex { pub index : runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderIndex } impl :: subxt :: Call for SetBestIndex { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "set_best_index" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetConfirmedIndex { pub index : runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderIndex } impl :: subxt :: Call for SetConfirmedIndex { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "set_confirmed_index" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemovePending { pub addr : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub who : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > } impl :: subxt :: Call for RemovePending { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "remove_pending" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemoveProposal { } impl :: subxt :: Call for RemoveProposal { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "remove_proposal" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceReplaceProposalTx { pub tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for ForceReplaceProposalTx { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "force_replace_proposal_tx" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetBtcWithdrawalFee { # [codec (compact)] pub fee : :: core :: primitive :: u64 } impl :: subxt :: Call for SetBtcWithdrawalFee { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "set_btc_withdrawal_fee" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetBtcDepositLimit { # [codec (compact)] pub value : :: core :: primitive :: u64 } impl :: subxt :: Call for SetBtcDepositLimit { const PALLET : & 'static str = "XGatewayBitcoin" ; const FUNCTION : & 'static str = "set_btc_deposit_limit" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn push_header (& self , header : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , PushHeader > { let call = PushHeader { header , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn push_transaction (& self , raw_tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > , relayed_info : runtime_types :: xpallet_gateway_bitcoin :: types :: BtcRelayedTxInfo , prev_tx : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ,) -> :: subxt :: SubmittableExtrinsic < T , PushTransaction > { let call = PushTransaction { raw_tx , relayed_info , prev_tx , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn create_withdraw_tx (& self , withdrawal_id_list : :: std :: vec :: Vec < :: core :: primitive :: u32 > , tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , CreateWithdrawTx > { let call = CreateWithdrawTx { withdrawal_id_list , tx , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn create_taproot_withdraw_tx (& self , withdrawal_id_list : :: std :: vec :: Vec < :: core :: primitive :: u32 > , tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > , spent_outputs : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , CreateTaprootWithdrawTx > { let call = CreateTaprootWithdrawTx { withdrawal_id_list , tx , spent_outputs , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn sign_withdraw_tx (& self , tx : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ,) -> :: subxt :: SubmittableExtrinsic < T , SignWithdrawTx > { let call = SignWithdrawTx { tx , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_best_index (& self , index : runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderIndex ,) -> :: subxt :: SubmittableExtrinsic < T , SetBestIndex > { let call = SetBestIndex { index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_confirmed_index (& self , index : runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderIndex ,) -> :: subxt :: SubmittableExtrinsic < T , SetConfirmedIndex > { let call = SetConfirmedIndex { index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_pending (& self , addr : :: std :: vec :: Vec < :: core :: primitive :: u8 > , who : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > ,) -> :: subxt :: SubmittableExtrinsic < T , RemovePending > { let call = RemovePending { addr , who , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_proposal (& self ,) -> :: subxt :: SubmittableExtrinsic < T , RemoveProposal > { let call = RemoveProposal { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn force_replace_proposal_tx (& self , tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , ForceReplaceProposalTx > { let call = ForceReplaceProposalTx { tx , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_btc_withdrawal_fee (& self , fee : :: core :: primitive :: u64 ,) -> :: subxt :: SubmittableExtrinsic < T , SetBtcWithdrawalFee > { let call = SetBtcWithdrawalFee { fee , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_btc_deposit_limit (& self , value : :: core :: primitive :: u64 ,) -> :: subxt :: SubmittableExtrinsic < T , SetBtcDepositLimit > { let call = SetBtcDepositLimit { value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: xpallet_gateway_bitcoin :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct HeaderInserted (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for HeaderInserted { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "HeaderInserted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TxProcessed (pub :: subxt :: sp_core :: H256 , pub :: subxt :: sp_core :: H256 , pub runtime_types :: xpallet_gateway_bitcoin :: types :: BtcTxState) ; impl :: subxt :: Event for TxProcessed { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "TxProcessed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Deposited (pub :: subxt :: sp_core :: H256 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Deposited { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "Deposited" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Withdrawn (pub :: subxt :: sp_core :: H256 , pub :: std :: vec :: Vec < :: core :: primitive :: u32 > , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Withdrawn { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "Withdrawn" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct UnclaimedDeposit (pub :: subxt :: sp_core :: H256 , pub :: std :: vec :: Vec < :: core :: primitive :: u8 >) ; impl :: subxt :: Event for UnclaimedDeposit { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "UnclaimedDeposit" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PendingDepositRemoved (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128 , pub :: subxt :: sp_core :: H256 , pub :: std :: vec :: Vec < :: core :: primitive :: u8 >) ; impl :: subxt :: Event for PendingDepositRemoved { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "PendingDepositRemoved" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalProposalCreated (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: std :: vec :: Vec < :: core :: primitive :: u32 >) ; impl :: subxt :: Event for WithdrawalProposalCreated { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "WithdrawalProposalCreated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalProposalVoted (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: bool) ; impl :: subxt :: Event for WithdrawalProposalVoted { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "WithdrawalProposalVoted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalProposalDropped (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u32 , pub :: std :: vec :: Vec < :: core :: primitive :: u32 >) ; impl :: subxt :: Event for WithdrawalProposalDropped { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "WithdrawalProposalDropped" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalProposalCompleted (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for WithdrawalProposalCompleted { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "WithdrawalProposalCompleted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalFatalErr (pub :: subxt :: sp_core :: H256 , pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for WithdrawalFatalErr { const PALLET : & 'static str = "XGatewayBitcoin" ; const EVENT : & 'static str = "WithdrawalFatalErr" ; } } pub mod storage { use super :: runtime_types ; pub struct BestIndex ; impl :: subxt :: StorageEntry for BestIndex { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "BestIndex" ; type Value = runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderIndex ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ConfirmedIndex ; impl :: subxt :: StorageEntry for ConfirmedIndex { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "ConfirmedIndex" ; type Value = runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderIndex ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct BlockHashFor (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for BlockHashFor { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "BlockHashFor" ; type Value = :: std :: vec :: Vec < :: subxt :: sp_core :: H256 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct MainChain (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for MainChain { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "MainChain" ; type Value = :: core :: primitive :: bool ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct Headers (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Headers { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "Headers" ; type Value = runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderInfo ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct TxState (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for TxState { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "TxState" ; type Value = runtime_types :: xpallet_gateway_bitcoin :: types :: BtcTxState ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct PendingDeposits (pub :: std :: vec :: Vec < :: core :: primitive :: u8 >) ; impl :: subxt :: StorageEntry for PendingDeposits { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "PendingDeposits" ; type Value = :: std :: vec :: Vec < runtime_types :: xpallet_gateway_bitcoin :: types :: BtcDepositCache > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Blake2_128Concat)]) } } pub struct WithdrawalProposal ; impl :: subxt :: StorageEntry for WithdrawalProposal { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "WithdrawalProposal" ; type Value = runtime_types :: xpallet_gateway_bitcoin :: types :: BtcWithdrawalProposal < :: subxt :: sp_core :: crypto :: AccountId32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct GenesisInfo ; impl :: subxt :: StorageEntry for GenesisInfo { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "GenesisInfo" ; type Value = (runtime_types :: light_bitcoin_chain :: block_header :: BlockHeader , :: core :: primitive :: u32 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ParamsInfo ; impl :: subxt :: StorageEntry for ParamsInfo { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "ParamsInfo" ; type Value = runtime_types :: xpallet_gateway_bitcoin :: types :: BtcParams ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NetworkId ; impl :: subxt :: StorageEntry for NetworkId { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "NetworkId" ; type Value = runtime_types :: light_bitcoin_keys :: address :: Network ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct ConfirmationNumber ; impl :: subxt :: StorageEntry for ConfirmationNumber { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "ConfirmationNumber" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct BtcWithdrawalFee ; impl :: subxt :: StorageEntry for BtcWithdrawalFee { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "BtcWithdrawalFee" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct BtcMinDeposit ; impl :: subxt :: StorageEntry for BtcMinDeposit { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "BtcMinDeposit" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct MaxWithdrawalCount ; impl :: subxt :: StorageEntry for MaxWithdrawalCount { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "MaxWithdrawalCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Verifier ; impl :: subxt :: StorageEntry for Verifier { const PALLET : & 'static str = "XGatewayBitcoin" ; const STORAGE : & 'static str = "Verifier" ; type Value = runtime_types :: xpallet_gateway_bitcoin :: types :: BtcTxVerifier ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn best_index (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderIndex , :: subxt :: Error > { let entry = BestIndex ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn confirmed_index (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderIndex > , :: subxt :: Error > { let entry = ConfirmedIndex ; self . client . storage () . fetch (& entry , hash) . await } pub async fn block_hash_for (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: subxt :: sp_core :: H256 > , :: subxt :: Error > { let entry = BlockHashFor (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn block_hash_for_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , BlockHashFor > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn main_chain (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: bool , :: subxt :: Error > { let entry = MainChain (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn main_chain_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , MainChain > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn headers (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderInfo > , :: subxt :: Error > { let entry = Headers (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn headers_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Headers > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn tx_state (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_gateway_bitcoin :: types :: BtcTxState > , :: subxt :: Error > { let entry = TxState (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn tx_state_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TxState > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn pending_deposits (& self , _0 : :: std :: vec :: Vec < :: core :: primitive :: u8 > , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < runtime_types :: xpallet_gateway_bitcoin :: types :: BtcDepositCache > , :: subxt :: Error > { let entry = PendingDeposits (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn pending_deposits_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , PendingDeposits > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn withdrawal_proposal (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_gateway_bitcoin :: types :: BtcWithdrawalProposal < :: subxt :: sp_core :: crypto :: AccountId32 > > , :: subxt :: Error > { let entry = WithdrawalProposal ; self . client . storage () . fetch (& entry , hash) . await } pub async fn genesis_info (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < (runtime_types :: light_bitcoin_chain :: block_header :: BlockHeader , :: core :: primitive :: u32 ,) , :: subxt :: Error > { let entry = GenesisInfo ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn params_info (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_gateway_bitcoin :: types :: BtcParams , :: subxt :: Error > { let entry = ParamsInfo ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn network_id (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: light_bitcoin_keys :: address :: Network , :: subxt :: Error > { let entry = NetworkId ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn confirmation_number (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = ConfirmationNumber ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn btc_withdrawal_fee (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: Error > { let entry = BtcWithdrawalFee ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn btc_min_deposit (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: Error > { let entry = BtcMinDeposit ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn max_withdrawal_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = MaxWithdrawalCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn verifier (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_gateway_bitcoin :: types :: BtcTxVerifier , :: subxt :: Error > { let entry = Verifier ; self . client . storage () . fetch_or_default (& entry , hash) . await } } } } pub mod x_spot { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PutOrder { # [codec (compact)] pub pair_id : :: core :: primitive :: u32 , pub order_type : runtime_types :: xpallet_dex_spot :: types :: OrderType , pub side : runtime_types :: xpallet_dex_spot :: types :: Side , # [codec (compact)] pub amount : :: core :: primitive :: u128 , # [codec (compact)] pub price : :: core :: primitive :: u128 } impl :: subxt :: Call for PutOrder { const PALLET : & 'static str = "XSpot" ; const FUNCTION : & 'static str = "put_order" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CancelOrder { # [codec (compact)] pub pair_id : :: core :: primitive :: u32 , # [codec (compact)] pub order_id : :: core :: primitive :: u64 } impl :: subxt :: Call for CancelOrder { const PALLET : & 'static str = "XSpot" ; const FUNCTION : & 'static str = "cancel_order" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ForceCancelOrder { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub pair_id : :: core :: primitive :: u32 , # [codec (compact)] pub order_id : :: core :: primitive :: u64 } impl :: subxt :: Call for ForceCancelOrder { const PALLET : & 'static str = "XSpot" ; const FUNCTION : & 'static str = "force_cancel_order" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetHandicap { # [codec (compact)] pub pair_id : :: core :: primitive :: u32 , pub new : runtime_types :: xpallet_dex_spot :: types :: Handicap < :: core :: primitive :: u128 > } impl :: subxt :: Call for SetHandicap { const PALLET : & 'static str = "XSpot" ; const FUNCTION : & 'static str = "set_handicap" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetPriceFluctuation { # [codec (compact)] pub pair_id : :: core :: primitive :: u32 , # [codec (compact)] pub new : :: core :: primitive :: u32 } impl :: subxt :: Call for SetPriceFluctuation { const PALLET : & 'static str = "XSpot" ; const FUNCTION : & 'static str = "set_price_fluctuation" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AddTradingPair { pub currency_pair : runtime_types :: xpallet_dex_spot :: types :: CurrencyPair , # [codec (compact)] pub pip_decimals : :: core :: primitive :: u32 , # [codec (compact)] pub tick_decimals : :: core :: primitive :: u32 , # [codec (compact)] pub latest_price : :: core :: primitive :: u128 , pub tradable : :: core :: primitive :: bool } impl :: subxt :: Call for AddTradingPair { const PALLET : & 'static str = "XSpot" ; const FUNCTION : & 'static str = "add_trading_pair" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct UpdateTradingPair { # [codec (compact)] pub pair_id : :: core :: primitive :: u32 , # [codec (compact)] pub tick_decimals : :: core :: primitive :: u32 , pub tradable : :: core :: primitive :: bool } impl :: subxt :: Call for UpdateTradingPair { const PALLET : & 'static str = "XSpot" ; const FUNCTION : & 'static str = "update_trading_pair" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn put_order (& self , pair_id : :: core :: primitive :: u32 , order_type : runtime_types :: xpallet_dex_spot :: types :: OrderType , side : runtime_types :: xpallet_dex_spot :: types :: Side , amount : :: core :: primitive :: u128 , price : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , PutOrder > { let call = PutOrder { pair_id , order_type , side , amount , price , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn cancel_order (& self , pair_id : :: core :: primitive :: u32 , order_id : :: core :: primitive :: u64 ,) -> :: subxt :: SubmittableExtrinsic < T , CancelOrder > { let call = CancelOrder { pair_id , order_id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn force_cancel_order (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pair_id : :: core :: primitive :: u32 , order_id : :: core :: primitive :: u64 ,) -> :: subxt :: SubmittableExtrinsic < T , ForceCancelOrder > { let call = ForceCancelOrder { who , pair_id , order_id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_handicap (& self , pair_id : :: core :: primitive :: u32 , new : runtime_types :: xpallet_dex_spot :: types :: Handicap < :: core :: primitive :: u128 > ,) -> :: subxt :: SubmittableExtrinsic < T , SetHandicap > { let call = SetHandicap { pair_id , new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_price_fluctuation (& self , pair_id : :: core :: primitive :: u32 , new : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , SetPriceFluctuation > { let call = SetPriceFluctuation { pair_id , new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn add_trading_pair (& self , currency_pair : runtime_types :: xpallet_dex_spot :: types :: CurrencyPair , pip_decimals : :: core :: primitive :: u32 , tick_decimals : :: core :: primitive :: u32 , latest_price : :: core :: primitive :: u128 , tradable : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , AddTradingPair > { let call = AddTradingPair { currency_pair , pip_decimals , tick_decimals , latest_price , tradable , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn update_trading_pair (& self , pair_id : :: core :: primitive :: u32 , tick_decimals : :: core :: primitive :: u32 , tradable : :: core :: primitive :: bool ,) -> :: subxt :: SubmittableExtrinsic < T , UpdateTradingPair > { let call = UpdateTradingPair { pair_id , tick_decimals , tradable , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: xpallet_dex_spot :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NewOrder (pub runtime_types :: xpallet_dex_spot :: types :: Order < :: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 >) ; impl :: subxt :: Event for NewOrder { const PALLET : & 'static str = "XSpot" ; const EVENT : & 'static str = "NewOrder" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MakerOrderUpdated (pub runtime_types :: xpallet_dex_spot :: types :: Order < :: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 >) ; impl :: subxt :: Event for MakerOrderUpdated { const PALLET : & 'static str = "XSpot" ; const EVENT : & 'static str = "MakerOrderUpdated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TakerOrderUpdated (pub runtime_types :: xpallet_dex_spot :: types :: Order < :: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 >) ; impl :: subxt :: Event for TakerOrderUpdated { const PALLET : & 'static str = "XSpot" ; const EVENT : & 'static str = "TakerOrderUpdated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct OrderExecuted (pub runtime_types :: xpallet_dex_spot :: types :: OrderExecutedInfo < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 , :: core :: primitive :: u128 >) ; impl :: subxt :: Event for OrderExecuted { const PALLET : & 'static str = "XSpot" ; const EVENT : & 'static str = "OrderExecuted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CanceledOrderUpdated (pub runtime_types :: xpallet_dex_spot :: types :: Order < :: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 >) ; impl :: subxt :: Event for CanceledOrderUpdated { const PALLET : & 'static str = "XSpot" ; const EVENT : & 'static str = "CanceledOrderUpdated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TradingPairAdded (pub runtime_types :: xpallet_dex_spot :: types :: TradingPairProfile) ; impl :: subxt :: Event for TradingPairAdded { const PALLET : & 'static str = "XSpot" ; const EVENT : & 'static str = "TradingPairAdded" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TradingPairUpdated (pub runtime_types :: xpallet_dex_spot :: types :: TradingPairProfile) ; impl :: subxt :: Event for TradingPairUpdated { const PALLET : & 'static str = "XSpot" ; const EVENT : & 'static str = "TradingPairUpdated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PriceFluctuationUpdated (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for PriceFluctuationUpdated { const PALLET : & 'static str = "XSpot" ; const EVENT : & 'static str = "PriceFluctuationUpdated" ; } } pub mod storage { use super :: runtime_types ; pub struct TradingPairCount ; impl :: subxt :: StorageEntry for TradingPairCount { const PALLET : & 'static str = "XSpot" ; const STORAGE : & 'static str = "TradingPairCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct NativeReserves (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for NativeReserves { const PALLET : & 'static str = "XSpot" ; const STORAGE : & 'static str = "NativeReserves" ; type Value = :: core :: primitive :: u128 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct TradingPairOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for TradingPairOf { const PALLET : & 'static str = "XSpot" ; const STORAGE : & 'static str = "TradingPairOf" ; type Value = runtime_types :: xpallet_dex_spot :: types :: TradingPairProfile ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct TradingPairInfoOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for TradingPairInfoOf { const PALLET : & 'static str = "XSpot" ; const STORAGE : & 'static str = "TradingPairInfoOf" ; type Value = runtime_types :: xpallet_dex_spot :: types :: TradingPairInfo < :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct TradingHistoryIndexOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for TradingHistoryIndexOf { const PALLET : & 'static str = "XSpot" ; const STORAGE : & 'static str = "TradingHistoryIndexOf" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct OrderCountOf (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for OrderCountOf { const PALLET : & 'static str = "XSpot" ; const STORAGE : & 'static str = "OrderCountOf" ; type Value = :: core :: primitive :: u64 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct OrderInfoOf (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u64) ; impl :: subxt :: StorageEntry for OrderInfoOf { const PALLET : & 'static str = "XSpot" ; const STORAGE : & 'static str = "OrderInfoOf" ; type Value = runtime_types :: xpallet_dex_spot :: types :: Order < :: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct QuotationsOf (:: core :: primitive :: u32 , :: core :: primitive :: u128) ; impl :: subxt :: StorageEntry for QuotationsOf { const PALLET : & 'static str = "XSpot" ; const STORAGE : & 'static str = "QuotationsOf" ; type Value = :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u64 ,) > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat) , :: subxt :: StorageMapKey :: new (& self . 1 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct HandicapOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for HandicapOf { const PALLET : & 'static str = "XSpot" ; const STORAGE : & 'static str = "HandicapOf" ; type Value = runtime_types :: xpallet_dex_spot :: types :: Handicap < :: core :: primitive :: u128 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct PriceFluctuationOf (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for PriceFluctuationOf { const PALLET : & 'static str = "XSpot" ; const STORAGE : & 'static str = "PriceFluctuationOf" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn trading_pair_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = TradingPairCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn native_reserves (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u128 , :: subxt :: Error > { let entry = NativeReserves (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn native_reserves_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , NativeReserves > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn trading_pair_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_dex_spot :: types :: TradingPairProfile > , :: subxt :: Error > { let entry = TradingPairOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn trading_pair_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TradingPairOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn trading_pair_info_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_dex_spot :: types :: TradingPairInfo < :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: Error > { let entry = TradingPairInfoOf (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn trading_pair_info_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TradingPairInfoOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn trading_history_index_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: Error > { let entry = TradingHistoryIndexOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn trading_history_index_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , TradingHistoryIndexOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn order_count_of (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u64 , :: subxt :: Error > { let entry = OrderCountOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn order_count_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , OrderCountOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn order_info_of (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , _1 : :: core :: primitive :: u64 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: xpallet_dex_spot :: types :: Order < :: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: Error > { let entry = OrderInfoOf (_0 , _1) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn order_info_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , OrderInfoOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn quotations_of (& self , _0 : :: core :: primitive :: u32 , _1 : :: core :: primitive :: u128 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u64 ,) > , :: subxt :: Error > { let entry = QuotationsOf (_0 , _1) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn quotations_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , QuotationsOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn handicap_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < runtime_types :: xpallet_dex_spot :: types :: Handicap < :: core :: primitive :: u128 > , :: subxt :: Error > { let entry = HandicapOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn handicap_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , HandicapOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn price_fluctuation_of (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = PriceFluctuationOf (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn price_fluctuation_of_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , PriceFluctuationOf > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod x_genesis_builder { use super :: runtime_types ; } pub mod currencies { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Transfer { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub currency_id : :: core :: primitive :: u32 , # [codec (compact)] pub amount : :: core :: primitive :: u128 } impl :: subxt :: Call for Transfer { const PALLET : & 'static str = "Currencies" ; const FUNCTION : & 'static str = "transfer" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TransferNativeCurrency { pub dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub amount : :: core :: primitive :: u128 } impl :: subxt :: Call for TransferNativeCurrency { const PALLET : & 'static str = "Currencies" ; const FUNCTION : & 'static str = "transfer_native_currency" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct UpdateBalance { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub currency_id : :: core :: primitive :: u32 , pub amount : :: core :: primitive :: i128 } impl :: subxt :: Call for UpdateBalance { const PALLET : & 'static str = "Currencies" ; const FUNCTION : & 'static str = "update_balance" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn transfer (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Transfer > { let call = Transfer { dest , currency_id , amount , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn transfer_native_currency (& self , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , amount : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , TransferNativeCurrency > { let call = TransferNativeCurrency { dest , amount , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn update_balance (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: i128 ,) -> :: subxt :: SubmittableExtrinsic < T , UpdateBalance > { let call = UpdateBalance { who , currency_id , amount , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: orml_currencies :: module :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Transferred (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Transferred { const PALLET : & 'static str = "Currencies" ; const EVENT : & 'static str = "Transferred" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BalanceUpdated (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: i128) ; impl :: subxt :: Event for BalanceUpdated { const PALLET : & 'static str = "Currencies" ; const EVENT : & 'static str = "BalanceUpdated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Deposited (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Deposited { const PALLET : & 'static str = "Currencies" ; const EVENT : & 'static str = "Deposited" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Withdrawn (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for Withdrawn { const PALLET : & 'static str = "Currencies" ; const EVENT : & 'static str = "Withdrawn" ; } } } pub mod x_transaction_fee { use super :: runtime_types ; pub type Event = runtime_types :: xpallet_transaction_fee :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct FeePaid (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for FeePaid { const PALLET : & 'static str = "XTransactionFee" ; const EVENT : & 'static str = "FeePaid" ; } } } pub mod proxy { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Proxy { pub real : :: subxt :: sp_core :: crypto :: AccountId32 , pub force_proxy_type : :: core :: option :: Option < runtime_types :: dev_runtime :: ProxyType > , pub call : runtime_types :: dev_runtime :: Call } impl :: subxt :: Call for Proxy { const PALLET : & 'static str = "Proxy" ; const FUNCTION : & 'static str = "proxy" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AddProxy { pub delegate : :: subxt :: sp_core :: crypto :: AccountId32 , pub proxy_type : runtime_types :: dev_runtime :: ProxyType , pub delay : :: core :: primitive :: u32 } impl :: subxt :: Call for AddProxy { const PALLET : & 'static str = "Proxy" ; const FUNCTION : & 'static str = "add_proxy" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemoveProxy { pub delegate : :: subxt :: sp_core :: crypto :: AccountId32 , pub proxy_type : runtime_types :: dev_runtime :: ProxyType , pub delay : :: core :: primitive :: u32 } impl :: subxt :: Call for RemoveProxy { const PALLET : & 'static str = "Proxy" ; const FUNCTION : & 'static str = "remove_proxy" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemoveProxies { } impl :: subxt :: Call for RemoveProxies { const PALLET : & 'static str = "Proxy" ; const FUNCTION : & 'static str = "remove_proxies" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Anonymous { pub proxy_type : runtime_types :: dev_runtime :: ProxyType , pub delay : :: core :: primitive :: u32 , pub index : :: core :: primitive :: u16 } impl :: subxt :: Call for Anonymous { const PALLET : & 'static str = "Proxy" ; const FUNCTION : & 'static str = "anonymous" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct KillAnonymous { pub spawner : :: subxt :: sp_core :: crypto :: AccountId32 , pub proxy_type : runtime_types :: dev_runtime :: ProxyType , pub index : :: core :: primitive :: u16 , # [codec (compact)] pub height : :: core :: primitive :: u32 , # [codec (compact)] pub ext_index : :: core :: primitive :: u32 } impl :: subxt :: Call for KillAnonymous { const PALLET : & 'static str = "Proxy" ; const FUNCTION : & 'static str = "kill_anonymous" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Announce { pub real : :: subxt :: sp_core :: crypto :: AccountId32 , pub call_hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for Announce { const PALLET : & 'static str = "Proxy" ; const FUNCTION : & 'static str = "announce" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RemoveAnnouncement { pub real : :: subxt :: sp_core :: crypto :: AccountId32 , pub call_hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for RemoveAnnouncement { const PALLET : & 'static str = "Proxy" ; const FUNCTION : & 'static str = "remove_announcement" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RejectAnnouncement { pub delegate : :: subxt :: sp_core :: crypto :: AccountId32 , pub call_hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for RejectAnnouncement { const PALLET : & 'static str = "Proxy" ; const FUNCTION : & 'static str = "reject_announcement" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ProxyAnnounced { pub delegate : :: subxt :: sp_core :: crypto :: AccountId32 , pub real : :: subxt :: sp_core :: crypto :: AccountId32 , pub force_proxy_type : :: core :: option :: Option < runtime_types :: dev_runtime :: ProxyType > , pub call : runtime_types :: dev_runtime :: Call } impl :: subxt :: Call for ProxyAnnounced { const PALLET : & 'static str = "Proxy" ; const FUNCTION : & 'static str = "proxy_announced" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn proxy (& self , real : :: subxt :: sp_core :: crypto :: AccountId32 , force_proxy_type : :: core :: option :: Option < runtime_types :: dev_runtime :: ProxyType > , call : runtime_types :: dev_runtime :: Call ,) -> :: subxt :: SubmittableExtrinsic < T , Proxy > { let call = Proxy { real , force_proxy_type , call , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn add_proxy (& self , delegate : :: subxt :: sp_core :: crypto :: AccountId32 , proxy_type : runtime_types :: dev_runtime :: ProxyType , delay : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , AddProxy > { let call = AddProxy { delegate , proxy_type , delay , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_proxy (& self , delegate : :: subxt :: sp_core :: crypto :: AccountId32 , proxy_type : runtime_types :: dev_runtime :: ProxyType , delay : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , RemoveProxy > { let call = RemoveProxy { delegate , proxy_type , delay , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_proxies (& self ,) -> :: subxt :: SubmittableExtrinsic < T , RemoveProxies > { let call = RemoveProxies { } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn anonymous (& self , proxy_type : runtime_types :: dev_runtime :: ProxyType , delay : :: core :: primitive :: u32 , index : :: core :: primitive :: u16 ,) -> :: subxt :: SubmittableExtrinsic < T , Anonymous > { let call = Anonymous { proxy_type , delay , index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn kill_anonymous (& self , spawner : :: subxt :: sp_core :: crypto :: AccountId32 , proxy_type : runtime_types :: dev_runtime :: ProxyType , index : :: core :: primitive :: u16 , height : :: core :: primitive :: u32 , ext_index : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , KillAnonymous > { let call = KillAnonymous { spawner , proxy_type , index , height , ext_index , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn announce (& self , real : :: subxt :: sp_core :: crypto :: AccountId32 , call_hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , Announce > { let call = Announce { real , call_hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn remove_announcement (& self , real : :: subxt :: sp_core :: crypto :: AccountId32 , call_hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , RemoveAnnouncement > { let call = RemoveAnnouncement { real , call_hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn reject_announcement (& self , delegate : :: subxt :: sp_core :: crypto :: AccountId32 , call_hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , RejectAnnouncement > { let call = RejectAnnouncement { delegate , call_hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn proxy_announced (& self , delegate : :: subxt :: sp_core :: crypto :: AccountId32 , real : :: subxt :: sp_core :: crypto :: AccountId32 , force_proxy_type : :: core :: option :: Option < runtime_types :: dev_runtime :: ProxyType > , call : runtime_types :: dev_runtime :: Call ,) -> :: subxt :: SubmittableExtrinsic < T , ProxyAnnounced > { let call = ProxyAnnounced { delegate , real , force_proxy_type , call , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_proxy :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ProxyExecuted (pub :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError >) ; impl :: subxt :: Event for ProxyExecuted { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "ProxyExecuted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AnonymousCreated (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: dev_runtime :: ProxyType , pub :: core :: primitive :: u16) ; impl :: subxt :: Event for AnonymousCreated { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "AnonymousCreated" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Announced (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for Announced { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "Announced" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ProxyAdded (pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub runtime_types :: dev_runtime :: ProxyType , pub :: core :: primitive :: u32) ; impl :: subxt :: Event for ProxyAdded { const PALLET : & 'static str = "Proxy" ; const EVENT : & 'static str = "ProxyAdded" ; } } pub mod storage { use super :: runtime_types ; pub struct Proxies (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Proxies { const PALLET : & 'static str = "Proxy" ; const STORAGE : & 'static str = "Proxies" ; type Value = (runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < runtime_types :: pallet_proxy :: ProxyDefinition < :: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: dev_runtime :: ProxyType , :: core :: primitive :: u32 > > , :: core :: primitive :: u128 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Announcements (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: StorageEntry for Announcements { const PALLET : & 'static str = "Proxy" ; const STORAGE : & 'static str = "Announcements" ; type Value = (runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < runtime_types :: pallet_proxy :: Announcement < :: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > > , :: core :: primitive :: u128 ,) ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn proxies (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < (runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < runtime_types :: pallet_proxy :: ProxyDefinition < :: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: dev_runtime :: ProxyType , :: core :: primitive :: u32 > > , :: core :: primitive :: u128 ,) , :: subxt :: Error > { let entry = Proxies (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn proxies_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Proxies > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn announcements (& self , _0 : :: subxt :: sp_core :: crypto :: AccountId32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < (runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < runtime_types :: pallet_proxy :: Announcement < :: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > > , :: core :: primitive :: u128 ,) , :: subxt :: Error > { let entry = Announcements (_0) ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn announcements_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Announcements > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod bounties { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ProposeBounty { # [codec (compact)] pub value : :: core :: primitive :: u128 , pub description : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for ProposeBounty { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "propose_bounty" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ApproveBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 } impl :: subxt :: Call for ApproveBounty { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "approve_bounty" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ProposeCurator { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , pub curator : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pub fee : :: core :: primitive :: u128 } impl :: subxt :: Call for ProposeCurator { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "propose_curator" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct UnassignCurator { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 } impl :: subxt :: Call for UnassignCurator { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "unassign_curator" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AcceptCurator { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 } impl :: subxt :: Call for AcceptCurator { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "accept_curator" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AwardBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , pub beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > } impl :: subxt :: Call for AwardBounty { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "award_bounty" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ClaimBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 } impl :: subxt :: Call for ClaimBounty { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "claim_bounty" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CloseBounty { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 } impl :: subxt :: Call for CloseBounty { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "close_bounty" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ExtendBountyExpiry { # [codec (compact)] pub bounty_id : :: core :: primitive :: u32 , pub remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > } impl :: subxt :: Call for ExtendBountyExpiry { const PALLET : & 'static str = "Bounties" ; const FUNCTION : & 'static str = "extend_bounty_expiry" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn propose_bounty (& self , value : :: core :: primitive :: u128 , description : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , ProposeBounty > { let call = ProposeBounty { value , description , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn approve_bounty (& self , bounty_id : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , ApproveBounty > { let call = ApproveBounty { bounty_id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn propose_curator (& self , bounty_id : :: core :: primitive :: u32 , curator : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , fee : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , ProposeCurator > { let call = ProposeCurator { bounty_id , curator , fee , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn unassign_curator (& self , bounty_id : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , UnassignCurator > { let call = UnassignCurator { bounty_id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn accept_curator (& self , bounty_id : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , AcceptCurator > { let call = AcceptCurator { bounty_id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn award_bounty (& self , bounty_id : :: core :: primitive :: u32 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: SubmittableExtrinsic < T , AwardBounty > { let call = AwardBounty { bounty_id , beneficiary , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn claim_bounty (& self , bounty_id : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , ClaimBounty > { let call = ClaimBounty { bounty_id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn close_bounty (& self , bounty_id : :: core :: primitive :: u32 ,) -> :: subxt :: SubmittableExtrinsic < T , CloseBounty > { let call = CloseBounty { bounty_id , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn extend_bounty_expiry (& self , bounty_id : :: core :: primitive :: u32 , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) -> :: subxt :: SubmittableExtrinsic < T , ExtendBountyExpiry > { let call = ExtendBountyExpiry { bounty_id , remark , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_bounties :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BountyProposed (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for BountyProposed { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyProposed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BountyRejected (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for BountyRejected { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyRejected" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BountyBecameActive (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for BountyBecameActive { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyBecameActive" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BountyAwarded (pub :: core :: primitive :: u32 , pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for BountyAwarded { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyAwarded" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BountyClaimed (pub :: core :: primitive :: u32 , pub :: core :: primitive :: u128 , pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for BountyClaimed { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyClaimed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BountyCanceled (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for BountyCanceled { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyCanceled" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BountyExtended (pub :: core :: primitive :: u32) ; impl :: subxt :: Event for BountyExtended { const PALLET : & 'static str = "Bounties" ; const EVENT : & 'static str = "BountyExtended" ; } } pub mod storage { use super :: runtime_types ; pub struct BountyCount ; impl :: subxt :: StorageEntry for BountyCount { const PALLET : & 'static str = "Bounties" ; const STORAGE : & 'static str = "BountyCount" ; type Value = :: core :: primitive :: u32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct Bounties (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for Bounties { const PALLET : & 'static str = "Bounties" ; const STORAGE : & 'static str = "Bounties" ; type Value = runtime_types :: pallet_bounties :: Bounty < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct BountyDescriptions (pub :: core :: primitive :: u32) ; impl :: subxt :: StorageEntry for BountyDescriptions { const PALLET : & 'static str = "Bounties" ; const STORAGE : & 'static str = "BountyDescriptions" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct BountyApprovals ; impl :: subxt :: StorageEntry for BountyApprovals { const PALLET : & 'static str = "Bounties" ; const STORAGE : & 'static str = "BountyApprovals" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u32 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn bounty_count (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: primitive :: u32 , :: subxt :: Error > { let entry = BountyCount ; self . client . storage () . fetch_or_default (& entry , hash) . await } pub async fn bounties (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_bounties :: Bounty < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > > , :: subxt :: Error > { let entry = Bounties (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn bounties_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Bounties > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn bounty_descriptions (& self , _0 : :: core :: primitive :: u32 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: subxt :: Error > { let entry = BountyDescriptions (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn bounty_descriptions_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , BountyDescriptions > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn bounty_approvals (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: std :: vec :: Vec < :: core :: primitive :: u32 > , :: subxt :: Error > { let entry = BountyApprovals ; self . client . storage () . fetch_or_default (& entry , hash) . await } } } } pub mod tips { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ReportAwesome { pub reason : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub who : :: subxt :: sp_core :: crypto :: AccountId32 } impl :: subxt :: Call for ReportAwesome { const PALLET : & 'static str = "Tips" ; const FUNCTION : & 'static str = "report_awesome" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RetractTip { pub hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for RetractTip { const PALLET : & 'static str = "Tips" ; const FUNCTION : & 'static str = "retract_tip" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TipNew { pub reason : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub who : :: subxt :: sp_core :: crypto :: AccountId32 , # [codec (compact)] pub tip_value : :: core :: primitive :: u128 } impl :: subxt :: Call for TipNew { const PALLET : & 'static str = "Tips" ; const FUNCTION : & 'static str = "tip_new" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Tip { pub hash : :: subxt :: sp_core :: H256 , # [codec (compact)] pub tip_value : :: core :: primitive :: u128 } impl :: subxt :: Call for Tip { const PALLET : & 'static str = "Tips" ; const FUNCTION : & 'static str = "tip" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CloseTip { pub hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for CloseTip { const PALLET : & 'static str = "Tips" ; const FUNCTION : & 'static str = "close_tip" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SlashTip { pub hash : :: subxt :: sp_core :: H256 } impl :: subxt :: Call for SlashTip { const PALLET : & 'static str = "Tips" ; const FUNCTION : & 'static str = "slash_tip" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn report_awesome (& self , reason : :: std :: vec :: Vec < :: core :: primitive :: u8 > , who : :: subxt :: sp_core :: crypto :: AccountId32 ,) -> :: subxt :: SubmittableExtrinsic < T , ReportAwesome > { let call = ReportAwesome { reason , who , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn retract_tip (& self , hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , RetractTip > { let call = RetractTip { hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn tip_new (& self , reason : :: std :: vec :: Vec < :: core :: primitive :: u8 > , who : :: subxt :: sp_core :: crypto :: AccountId32 , tip_value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , TipNew > { let call = TipNew { reason , who , tip_value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn tip (& self , hash : :: subxt :: sp_core :: H256 , tip_value : :: core :: primitive :: u128 ,) -> :: subxt :: SubmittableExtrinsic < T , Tip > { let call = Tip { hash , tip_value , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn close_tip (& self , hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , CloseTip > { let call = CloseTip { hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn slash_tip (& self , hash : :: subxt :: sp_core :: H256 ,) -> :: subxt :: SubmittableExtrinsic < T , SlashTip > { let call = SlashTip { hash , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_tips :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NewTip (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for NewTip { const PALLET : & 'static str = "Tips" ; const EVENT : & 'static str = "NewTip" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TipClosing (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for TipClosing { const PALLET : & 'static str = "Tips" ; const EVENT : & 'static str = "TipClosing" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TipClosed (pub :: subxt :: sp_core :: H256 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for TipClosed { const PALLET : & 'static str = "Tips" ; const EVENT : & 'static str = "TipClosed" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TipRetracted (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: Event for TipRetracted { const PALLET : & 'static str = "Tips" ; const EVENT : & 'static str = "TipRetracted" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TipSlashed (pub :: subxt :: sp_core :: H256 , pub :: subxt :: sp_core :: crypto :: AccountId32 , pub :: core :: primitive :: u128) ; impl :: subxt :: Event for TipSlashed { const PALLET : & 'static str = "Tips" ; const EVENT : & 'static str = "TipSlashed" ; } } pub mod storage { use super :: runtime_types ; pub struct Tips (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Tips { const PALLET : & 'static str = "Tips" ; const STORAGE : & 'static str = "Tips" ; type Value = runtime_types :: pallet_tips :: OpenTip < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Twox64Concat)]) } } pub struct Reasons (pub :: subxt :: sp_core :: H256) ; impl :: subxt :: StorageEntry for Reasons { const PALLET : & 'static str = "Tips" ; const STORAGE : & 'static str = "Reasons" ; type Value = :: std :: vec :: Vec < :: core :: primitive :: u8 > ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Map (vec ! [:: subxt :: StorageMapKey :: new (& self . 0 , :: subxt :: StorageHasher :: Identity)]) } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn tips (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < runtime_types :: pallet_tips :: OpenTip < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 > > , :: subxt :: Error > { let entry = Tips (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn tips_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Tips > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } pub async fn reasons (& self , _0 : :: subxt :: sp_core :: H256 , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: subxt :: Error > { let entry = Reasons (_0) ; self . client . storage () . fetch (& entry , hash) . await } pub async fn reasons_iter (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: KeyIter < 'a , T , Reasons > , :: subxt :: Error > { self . client . storage () . iter (hash) . await } } } } pub mod sudo { use super :: runtime_types ; pub mod calls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Sudo { pub call : runtime_types :: dev_runtime :: Call } impl :: subxt :: Call for Sudo { const PALLET : & 'static str = "Sudo" ; const FUNCTION : & 'static str = "sudo" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SudoUncheckedWeight { pub call : runtime_types :: dev_runtime :: Call , pub weight : :: core :: primitive :: u64 } impl :: subxt :: Call for SudoUncheckedWeight { const PALLET : & 'static str = "Sudo" ; const FUNCTION : & 'static str = "sudo_unchecked_weight" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SetKey { pub new : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > } impl :: subxt :: Call for SetKey { const PALLET : & 'static str = "Sudo" ; const FUNCTION : & 'static str = "set_key" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SudoAs { pub who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , pub call : runtime_types :: dev_runtime :: Call } impl :: subxt :: Call for SudoAs { const PALLET : & 'static str = "Sudo" ; const FUNCTION : & 'static str = "sudo_as" ; } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub fn sudo (& self , call : runtime_types :: dev_runtime :: Call ,) -> :: subxt :: SubmittableExtrinsic < T , Sudo > { let call = Sudo { call , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn sudo_unchecked_weight (& self , call : runtime_types :: dev_runtime :: Call , weight : :: core :: primitive :: u64 ,) -> :: subxt :: SubmittableExtrinsic < T , SudoUncheckedWeight > { let call = SudoUncheckedWeight { call , weight , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn set_key (& self , new : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > ,) -> :: subxt :: SubmittableExtrinsic < T , SetKey > { let call = SetKey { new , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } pub fn sudo_as (& self , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , call : runtime_types :: dev_runtime :: Call ,) -> :: subxt :: SubmittableExtrinsic < T , SudoAs > { let call = SudoAs { who , call , } ; :: subxt :: SubmittableExtrinsic :: new (self . client , call) } } } pub type Event = runtime_types :: pallet_sudo :: pallet :: Event ; pub mod events { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Sudid (pub :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError >) ; impl :: subxt :: Event for Sudid { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "Sudid" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct KeyChanged (pub :: subxt :: sp_core :: crypto :: AccountId32) ; impl :: subxt :: Event for KeyChanged { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "KeyChanged" ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SudoAsDone (pub :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError >) ; impl :: subxt :: Event for SudoAsDone { const PALLET : & 'static str = "Sudo" ; const EVENT : & 'static str = "SudoAsDone" ; } } pub mod storage { use super :: runtime_types ; pub struct Key ; impl :: subxt :: StorageEntry for Key { const PALLET : & 'static str = "Sudo" ; const STORAGE : & 'static str = "Key" ; type Value = :: subxt :: sp_core :: crypto :: AccountId32 ; fn key (& self) -> :: subxt :: StorageEntryKey { :: subxt :: StorageEntryKey :: Plain } } pub struct StorageApi < 'a , T : :: subxt :: Config > { client : & 'a :: subxt :: Client < T > , } impl < 'a , T : :: subxt :: Config > StorageApi < 'a , T > { pub fn new (client : & 'a :: subxt :: Client < T >) -> Self { Self { client } } pub async fn key (& self , hash : :: core :: option :: Option < T :: Hash > ,) -> :: core :: result :: Result < :: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: Error > { let entry = Key ; self . client . storage () . fetch_or_default (& entry , hash) . await } } } } pub mod runtime_types { use super :: runtime_types ; pub mod dev_runtime { use super :: runtime_types ; pub mod impls { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ChargeExtraFee { } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BaseFilter { } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Call ,) , # [codec (index = 2)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Call ,) , # [codec (index = 3)] Babe (runtime_types :: pallet_babe :: pallet :: Call ,) , # [codec (index = 4)] Timestamp (runtime_types :: pallet_timestamp :: pallet :: Call ,) , # [codec (index = 5)] Indices (runtime_types :: pallet_indices :: pallet :: Call ,) , # [codec (index = 6)] Balances (runtime_types :: pallet_balances :: pallet :: Call ,) , # [codec (index = 8)] Authorship (runtime_types :: pallet_authorship :: pallet :: Call ,) , # [codec (index = 11)] Session (runtime_types :: pallet_session :: pallet :: Call ,) , # [codec (index = 12)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Call ,) , # [codec (index = 13)] ImOnline (runtime_types :: pallet_im_online :: pallet :: Call ,) , # [codec (index = 15)] Democracy (runtime_types :: pallet_democracy :: pallet :: Call ,) , # [codec (index = 16)] Council (runtime_types :: pallet_collective :: pallet :: Call ,) , # [codec (index = 17)] TechnicalCommittee (runtime_types :: pallet_collective :: pallet :: Call ,) , # [codec (index = 18)] Elections (runtime_types :: pallet_elections_phragmen :: pallet :: Call ,) , # [codec (index = 19)] TechnicalMembership (runtime_types :: pallet_membership :: pallet :: Call ,) , # [codec (index = 20)] Treasury (runtime_types :: pallet_treasury :: pallet :: Call ,) , # [codec (index = 21)] Identity (runtime_types :: pallet_identity :: pallet :: Call ,) , # [codec (index = 22)] Utility (runtime_types :: pallet_utility :: pallet :: Call ,) , # [codec (index = 23)] Multisig (runtime_types :: pallet_multisig :: pallet :: Call ,) , # [codec (index = 24)] XSystem (runtime_types :: xpallet_system :: pallet :: Call ,) , # [codec (index = 25)] XAssetsRegistrar (runtime_types :: xpallet_assets_registrar :: pallet :: Call ,) , # [codec (index = 26)] XAssets (runtime_types :: xpallet_assets :: pallet :: Call ,) , # [codec (index = 27)] XStaking (runtime_types :: xpallet_mining_staking :: pallet :: Call ,) , # [codec (index = 28)] XMiningAsset (runtime_types :: xpallet_mining_asset :: pallet :: Call ,) , # [codec (index = 29)] XGatewayRecords (runtime_types :: xpallet_gateway_records :: pallet :: Call ,) , # [codec (index = 30)] XGatewayCommon (runtime_types :: xpallet_gateway_common :: pallet :: Call ,) , # [codec (index = 31)] XGatewayBitcoin (runtime_types :: xpallet_gateway_bitcoin :: pallet :: Call ,) , # [codec (index = 32)] XSpot (runtime_types :: xpallet_dex_spot :: pallet :: Call ,) , # [codec (index = 34)] Currencies (runtime_types :: orml_currencies :: module :: Call ,) , # [codec (index = 36)] Proxy (runtime_types :: pallet_proxy :: pallet :: Call ,) , # [codec (index = 37)] Bounties (runtime_types :: pallet_bounties :: pallet :: Call ,) , # [codec (index = 38)] Tips (runtime_types :: pallet_tips :: pallet :: Call ,) , # [codec (index = 39)] Sudo (runtime_types :: pallet_sudo :: pallet :: Call ,) , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] System (runtime_types :: frame_system :: pallet :: Event ,) , # [codec (index = 2)] Scheduler (runtime_types :: pallet_scheduler :: pallet :: Event ,) , # [codec (index = 5)] Indices (runtime_types :: pallet_indices :: pallet :: Event ,) , # [codec (index = 6)] Balances (runtime_types :: pallet_balances :: pallet :: Event ,) , # [codec (index = 9)] Offences (runtime_types :: pallet_offences :: pallet :: Event ,) , # [codec (index = 11)] Session (runtime_types :: pallet_session :: pallet :: Event ,) , # [codec (index = 12)] Grandpa (runtime_types :: pallet_grandpa :: pallet :: Event ,) , # [codec (index = 13)] ImOnline (runtime_types :: pallet_im_online :: pallet :: Event ,) , # [codec (index = 15)] Democracy (runtime_types :: pallet_democracy :: pallet :: Event ,) , # [codec (index = 16)] Council (runtime_types :: pallet_collective :: pallet :: Event ,) , # [codec (index = 17)] TechnicalCommittee (runtime_types :: pallet_collective :: pallet :: Event ,) , # [codec (index = 18)] Elections (runtime_types :: pallet_elections_phragmen :: pallet :: Event ,) , # [codec (index = 19)] TechnicalMembership (runtime_types :: pallet_membership :: pallet :: Event ,) , # [codec (index = 20)] Treasury (runtime_types :: pallet_treasury :: pallet :: Event ,) , # [codec (index = 21)] Identity (runtime_types :: pallet_identity :: pallet :: Event ,) , # [codec (index = 22)] Utility (runtime_types :: pallet_utility :: pallet :: Event ,) , # [codec (index = 23)] Multisig (runtime_types :: pallet_multisig :: pallet :: Event ,) , # [codec (index = 24)] XSystem (runtime_types :: xpallet_system :: pallet :: Event ,) , # [codec (index = 25)] XAssetsRegistrar (runtime_types :: xpallet_assets_registrar :: pallet :: Event ,) , # [codec (index = 26)] XAssets (runtime_types :: xpallet_assets :: pallet :: Event ,) , # [codec (index = 27)] XStaking (runtime_types :: xpallet_mining_staking :: pallet :: Event ,) , # [codec (index = 28)] XMiningAsset (runtime_types :: xpallet_mining_asset :: pallet :: Event ,) , # [codec (index = 29)] XGatewayRecords (runtime_types :: xpallet_gateway_records :: pallet :: Event ,) , # [codec (index = 30)] XGatewayCommon (runtime_types :: xpallet_gateway_common :: pallet :: Event ,) , # [codec (index = 31)] XGatewayBitcoin (runtime_types :: xpallet_gateway_bitcoin :: pallet :: Event ,) , # [codec (index = 32)] XSpot (runtime_types :: xpallet_dex_spot :: pallet :: Event ,) , # [codec (index = 34)] Currencies (runtime_types :: orml_currencies :: module :: Event ,) , # [codec (index = 35)] XTransactionFee (runtime_types :: xpallet_transaction_fee :: pallet :: Event ,) , # [codec (index = 36)] Proxy (runtime_types :: pallet_proxy :: pallet :: Event ,) , # [codec (index = 37)] Bounties (runtime_types :: pallet_bounties :: pallet :: Event ,) , # [codec (index = 38)] Tips (runtime_types :: pallet_tips :: pallet :: Event ,) , # [codec (index = 39)] Sudo (runtime_types :: pallet_sudo :: pallet :: Event ,) , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum OriginCaller { # [codec (index = 0)] system (runtime_types :: frame_system :: RawOrigin < :: subxt :: sp_core :: crypto :: AccountId32 > ,) , # [codec (index = 16)] Council (runtime_types :: pallet_collective :: RawOrigin < :: subxt :: sp_core :: crypto :: AccountId32 > ,) , # [codec (index = 17)] TechnicalCommittee (runtime_types :: pallet_collective :: RawOrigin < :: subxt :: sp_core :: crypto :: AccountId32 > ,) , # [codec (index = 3)] Void (runtime_types :: sp_core :: Void ,) , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum ProxyType { # [codec (index = 0)] Any , # [codec (index = 1)] NonTransfer , # [codec (index = 2)] Governance , # [codec (index = 3)] Staking , # [codec (index = 4)] IdentityJudgement , # [codec (index = 5)] CancelProxy , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Runtime { } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SessionKeys { pub babe : runtime_types :: sp_consensus_babe :: app :: Public , pub grandpa : runtime_types :: sp_finality_grandpa :: app :: Public , pub im_online : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public , pub authority_discovery : runtime_types :: sp_authority_discovery :: app :: Public , } } pub mod finality_grandpa { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Equivocation < _0 , _1 , _2 > { pub round_number : :: core :: primitive :: u64 , pub identity : _0 , pub first : (_1 , _2 ,) , pub second : (_1 , _2 ,) , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Precommit < _0 , _1 > { pub target_hash : _0 , pub target_number : _1 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Prevote < _0 , _1 > { pub target_hash : _0 , pub target_number : _1 , } } pub mod frame_support { use super :: runtime_types ; pub mod storage { use super :: runtime_types ; pub mod bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BoundedVec < _0 > (pub :: std :: vec :: Vec < _0 > ,) ; } pub mod weak_bounded_vec { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WeakBoundedVec < _0 > (pub :: std :: vec :: Vec < _0 > ,) ; } } pub mod traits { use super :: runtime_types ; pub mod misc { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WrapperOpaque < _0 > (:: core :: primitive :: u32 , pub _0 ,) ; } pub mod tokens { use super :: runtime_types ; pub mod misc { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum BalanceStatus { # [codec (index = 0)] Free , # [codec (index = 1)] Reserved , } } } } pub mod weights { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum DispatchClass { # [codec (index = 0)] Normal , # [codec (index = 1)] Operational , # [codec (index = 2)] Mandatory , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct DispatchInfo { pub weight : :: core :: primitive :: u64 , pub class : runtime_types :: frame_support :: weights :: DispatchClass , pub pays_fee : runtime_types :: frame_support :: weights :: Pays , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Pays { # [codec (index = 0)] Yes , # [codec (index = 1)] No , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PerDispatchClass < _0 > { pub normal : _0 , pub operational : _0 , pub mandatory : _0 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RuntimeDbWeight { pub read : :: core :: primitive :: u64 , pub write : :: core :: primitive :: u64 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WeightToFeeCoefficient < _0 > { pub coeff_integer : _0 , pub coeff_frac : runtime_types :: sp_arithmetic :: per_things :: Perbill , pub negative : :: core :: primitive :: bool , pub degree : :: core :: primitive :: u8 , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PalletId (pub [:: core :: primitive :: u8 ; 8usize] ,) ; } pub mod frame_system { use super :: runtime_types ; pub mod extensions { use super :: runtime_types ; pub mod check_genesis { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CheckGenesis { } } pub mod check_mortality { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CheckMortality (pub runtime_types :: sp_runtime :: generic :: era :: Era ,) ; } pub mod check_nonce { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CheckNonce (pub :: core :: primitive :: u32 ,) ; } pub mod check_spec_version { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CheckSpecVersion { } } pub mod check_tx_version { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CheckTxVersion { } } pub mod check_weight { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CheckWeight { } } } pub mod limits { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BlockLength { pub max : runtime_types :: frame_support :: weights :: PerDispatchClass < :: core :: primitive :: u32 > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BlockWeights { pub base_block : :: core :: primitive :: u64 , pub max_block : :: core :: primitive :: u64 , pub per_class : runtime_types :: frame_support :: weights :: PerDispatchClass < runtime_types :: frame_system :: limits :: WeightsPerClass > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WeightsPerClass { pub base_extrinsic : :: core :: primitive :: u64 , pub max_extrinsic : :: core :: option :: Option < :: core :: primitive :: u64 > , pub max_total : :: core :: option :: Option < :: core :: primitive :: u64 > , pub reserved : :: core :: option :: Option < :: core :: primitive :: u64 > , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] fill_block { ratio : runtime_types :: sp_arithmetic :: per_things :: Perbill , } , # [codec (index = 1)] remark { remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 2)] set_heap_pages { pages : :: core :: primitive :: u64 , } , # [codec (index = 3)] set_code { code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] set_code_without_checks { code : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 5)] set_changes_trie_config { changes_trie_config : :: core :: option :: Option < runtime_types :: sp_core :: changes_trie :: ChangesTrieConfiguration > , } , # [codec (index = 6)] set_storage { items : :: std :: vec :: Vec < (:: std :: vec :: Vec < :: core :: primitive :: u8 > , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) > , } , # [codec (index = 7)] kill_storage { keys : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } , # [codec (index = 8)] kill_prefix { prefix : :: std :: vec :: Vec < :: core :: primitive :: u8 > , subkeys : :: core :: primitive :: u32 , } , # [codec (index = 9)] remark_with_event { remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InvalidSpecName , # [codec (index = 1)] SpecVersionNeedsToIncrease , # [codec (index = 2)] FailedToExtractRuntimeVersion , # [codec (index = 3)] NonDefaultComposite , # [codec (index = 4)] NonZeroRefCount , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] ExtrinsicSuccess (runtime_types :: frame_support :: weights :: DispatchInfo ,) , # [codec (index = 1)] ExtrinsicFailed (runtime_types :: sp_runtime :: DispatchError , runtime_types :: frame_support :: weights :: DispatchInfo ,) , # [codec (index = 2)] CodeUpdated , # [codec (index = 3)] NewAccount (:: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 4)] KilledAccount (:: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 5)] Remarked (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: H256 ,) , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AccountInfo < _0 , _1 > { pub nonce : _0 , pub consumers : _0 , pub providers : _0 , pub sufficients : _0 , pub data : _1 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct EventRecord < _0 , _1 > { pub phase : runtime_types :: frame_system :: Phase , pub event : _0 , pub topics : :: std :: vec :: Vec < _1 > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct LastRuntimeUpgradeInfo { # [codec (compact)] pub spec_version : :: core :: primitive :: u32 , pub spec_name : :: std :: string :: String , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Phase { # [codec (index = 0)] ApplyExtrinsic (:: core :: primitive :: u32 ,) , # [codec (index = 1)] Finalization , # [codec (index = 2)] Initialization , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum RawOrigin < _0 > { # [codec (index = 0)] Root , # [codec (index = 1)] Signed (_0 ,) , # [codec (index = 2)] None , } } pub mod light_bitcoin_chain { use super :: runtime_types ; pub mod block_header { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BlockHeader { pub version : :: core :: primitive :: u32 , pub previous_header_hash : :: subxt :: sp_core :: H256 , pub merkle_root_hash : :: subxt :: sp_core :: H256 , pub time : :: core :: primitive :: u32 , pub bits : runtime_types :: light_bitcoin_primitives :: compact :: Compact , pub nonce : :: core :: primitive :: u32 , } } pub mod transaction { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct OutPoint { pub txid : :: subxt :: sp_core :: H256 , pub index : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Transaction { pub version : :: core :: primitive :: i32 , pub inputs : :: std :: vec :: Vec < runtime_types :: light_bitcoin_chain :: transaction :: TransactionInput > , pub outputs : :: std :: vec :: Vec < runtime_types :: light_bitcoin_chain :: transaction :: TransactionOutput > , pub lock_time : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TransactionInput { pub previous_output : runtime_types :: light_bitcoin_chain :: transaction :: OutPoint , pub script_sig : runtime_types :: light_bitcoin_primitives :: bytes :: Bytes , pub sequence : :: core :: primitive :: u32 , pub script_witness : :: std :: vec :: Vec < runtime_types :: light_bitcoin_primitives :: bytes :: Bytes > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TransactionOutput { pub value : :: core :: primitive :: u64 , pub script_pubkey : runtime_types :: light_bitcoin_primitives :: bytes :: Bytes , } } } pub mod light_bitcoin_keys { use super :: runtime_types ; pub mod address { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Network { # [codec (index = 0)] Mainnet , # [codec (index = 1)] Testnet , } } } pub mod light_bitcoin_merkle { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PartialMerkleTree { pub tx_count : :: core :: primitive :: u32 , pub hashes : :: std :: vec :: Vec < :: subxt :: sp_core :: H256 > , pub bits : :: std :: vec :: Vec < :: core :: primitive :: bool > , } } pub mod light_bitcoin_primitives { use super :: runtime_types ; pub mod bytes { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Bytes (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; } pub mod compact { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs)] # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Compact (pub :: core :: primitive :: u32 ,) ; } } pub mod orml_currencies { use super :: runtime_types ; pub mod module { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] transfer { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 1)] transfer_native_currency { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] amount : :: core :: primitive :: u128 , } , # [codec (index = 2)] update_balance { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , currency_id : :: core :: primitive :: u32 , amount : :: core :: primitive :: i128 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] AmountIntoBalanceFailed , # [codec (index = 1)] BalanceTooLow , # [codec (index = 2)] DepositFailed , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Transferred (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 1)] BalanceUpdated (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: i128 ,) , # [codec (index = 2)] Deposited (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 3)] Withdrawn (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , } } } pub mod pallet_authorship { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] set_uncles { new_uncles : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InvalidUncleParent , # [codec (index = 1)] UnclesAlreadySet , # [codec (index = 2)] TooManyUncles , # [codec (index = 3)] GenesisUncle , # [codec (index = 4)] TooHighUncle , # [codec (index = 5)] UncleAlreadyIncluded , # [codec (index = 6)] OldUncle , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum UncleEntryItem < _0 , _1 , _2 > { # [codec (index = 0)] InclusionHeight (_0 ,) , # [codec (index = 1)] Uncle (_1 , :: core :: option :: Option < _2 > ,) , } } pub mod pallet_babe { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] report_equivocation { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 1)] report_equivocation_unsigned { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_consensus_slots :: EquivocationProof < runtime_types :: sp_runtime :: generic :: header :: Header < :: core :: primitive :: u32 , runtime_types :: sp_runtime :: traits :: BlakeTwo256 > , runtime_types :: sp_consensus_babe :: app :: Public > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 2)] plan_config_change { config : runtime_types :: sp_consensus_babe :: digests :: NextConfigDescriptor , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InvalidEquivocationProof , # [codec (index = 1)] InvalidKeyOwnershipProof , # [codec (index = 2)] DuplicateOffenceReport , } } } pub mod pallet_balances { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] transfer { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] set_balance { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] new_free : :: core :: primitive :: u128 , # [codec (compact)] new_reserved : :: core :: primitive :: u128 , } , # [codec (index = 2)] force_transfer { source : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 3)] transfer_keep_alive { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 4)] transfer_all { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , keep_alive : :: core :: primitive :: bool , } , # [codec (index = 5)] force_unreserve { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , amount : :: core :: primitive :: u128 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] VestingBalance , # [codec (index = 1)] LiquidityRestrictions , # [codec (index = 2)] InsufficientBalance , # [codec (index = 3)] ExistentialDeposit , # [codec (index = 4)] KeepAlive , # [codec (index = 5)] ExistingVestingSchedule , # [codec (index = 6)] DeadAccount , # [codec (index = 7)] TooManyReserves , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Endowed (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 1)] DustLost (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 2)] Transfer (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 3)] BalanceSet (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 ,) , # [codec (index = 4)] Deposit (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 5)] Reserved (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 6)] Unreserved (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 7)] ReserveRepatriated (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , runtime_types :: frame_support :: traits :: tokens :: misc :: BalanceStatus ,) , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AccountData < _0 > { pub free : _0 , pub reserved : _0 , pub misc_frozen : _0 , pub fee_frozen : _0 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BalanceLock < _0 > { pub id : [:: core :: primitive :: u8 ; 8usize] , pub amount : _0 , pub reasons : runtime_types :: pallet_balances :: Reasons , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Reasons { # [codec (index = 0)] Fee , # [codec (index = 1)] Misc , # [codec (index = 2)] All , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Releases { # [codec (index = 0)] V1_0_0 , # [codec (index = 1)] V2_0_0 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ReserveData < _0 , _1 > { pub id : _0 , pub amount : _1 , } } pub mod pallet_bounties { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] propose_bounty { # [codec (compact)] value : :: core :: primitive :: u128 , description : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] approve_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] propose_curator { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , curator : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] fee : :: core :: primitive :: u128 , } , # [codec (index = 3)] unassign_curator { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 4)] accept_curator { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 5)] award_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 6)] claim_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 7)] close_bounty { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , } , # [codec (index = 8)] extend_bounty_expiry { # [codec (compact)] bounty_id : :: core :: primitive :: u32 , remark : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InsufficientProposersBalance , # [codec (index = 1)] InvalidIndex , # [codec (index = 2)] ReasonTooBig , # [codec (index = 3)] UnexpectedStatus , # [codec (index = 4)] RequireCurator , # [codec (index = 5)] InvalidValue , # [codec (index = 6)] InvalidFee , # [codec (index = 7)] PendingPayout , # [codec (index = 8)] Premature , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] BountyProposed (:: core :: primitive :: u32 ,) , # [codec (index = 1)] BountyRejected (:: core :: primitive :: u32 , :: core :: primitive :: u128 ,) , # [codec (index = 2)] BountyBecameActive (:: core :: primitive :: u32 ,) , # [codec (index = 3)] BountyAwarded (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 4)] BountyClaimed (:: core :: primitive :: u32 , :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 5)] BountyCanceled (:: core :: primitive :: u32 ,) , # [codec (index = 6)] BountyExtended (:: core :: primitive :: u32 ,) , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Bounty < _0 , _1 , _2 > { pub proposer : _0 , pub value : _1 , pub fee : _1 , pub curator_deposit : _1 , pub bond : _1 , pub status : runtime_types :: pallet_bounties :: BountyStatus < _0 , _2 > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum BountyStatus < _0 , _1 > { # [codec (index = 0)] Proposed , # [codec (index = 1)] Approved , # [codec (index = 2)] Funded , # [codec (index = 3)] CuratorProposed { curator : _0 , } , # [codec (index = 4)] Active { curator : _0 , update_due : _1 , } , # [codec (index = 5)] PendingPayout { curator : _0 , beneficiary : _0 , unlock_at : _1 , } , } } pub mod pallet_collective { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] set_members { new_members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , prime : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , old_count : :: core :: primitive :: u32 , } , # [codec (index = 1)] execute { proposal : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 2)] propose { # [codec (compact)] threshold : :: core :: primitive :: u32 , proposal : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 3)] vote { proposal : :: subxt :: sp_core :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , approve : :: core :: primitive :: bool , } , # [codec (index = 4)] close { proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] index : :: core :: primitive :: u32 , # [codec (compact)] proposal_weight_bound : :: core :: primitive :: u64 , # [codec (compact)] length_bound : :: core :: primitive :: u32 , } , # [codec (index = 5)] disapprove_proposal { proposal_hash : :: subxt :: sp_core :: H256 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] NotMember , # [codec (index = 1)] DuplicateProposal , # [codec (index = 2)] ProposalMissing , # [codec (index = 3)] WrongIndex , # [codec (index = 4)] DuplicateVote , # [codec (index = 5)] AlreadyInitialized , # [codec (index = 6)] TooEarly , # [codec (index = 7)] TooManyProposals , # [codec (index = 8)] WrongProposalWeight , # [codec (index = 9)] WrongProposalLength , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Proposed (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 , :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 ,) , # [codec (index = 1)] Voted (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: H256 , :: core :: primitive :: bool , :: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , # [codec (index = 2)] Approved (:: subxt :: sp_core :: H256 ,) , # [codec (index = 3)] Disapproved (:: subxt :: sp_core :: H256 ,) , # [codec (index = 4)] Executed (:: subxt :: sp_core :: H256 , :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ,) , # [codec (index = 5)] MemberExecuted (:: subxt :: sp_core :: H256 , :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ,) , # [codec (index = 6)] Closed (:: subxt :: sp_core :: H256 , :: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum RawOrigin < _0 > { # [codec (index = 0)] Members (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , # [codec (index = 1)] Member (_0 ,) , # [codec (index = 2)] _Phantom , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Votes < _0 , _1 > { pub index : _1 , pub threshold : _1 , pub ayes : :: std :: vec :: Vec < _0 > , pub nays : :: std :: vec :: Vec < _0 > , pub end : _1 , } } pub mod pallet_democracy { use super :: runtime_types ; pub mod conviction { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Conviction { # [codec (index = 0)] None , # [codec (index = 1)] Locked1x , # [codec (index = 2)] Locked2x , # [codec (index = 3)] Locked3x , # [codec (index = 4)] Locked4x , # [codec (index = 5)] Locked5x , # [codec (index = 6)] Locked6x , } } pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] propose { proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] second { # [codec (compact)] proposal : :: core :: primitive :: u32 , # [codec (compact)] seconds_upper_bound : :: core :: primitive :: u32 , } , # [codec (index = 2)] vote { # [codec (compact)] ref_index : :: core :: primitive :: u32 , vote : runtime_types :: pallet_democracy :: vote :: AccountVote < :: core :: primitive :: u128 > , } , # [codec (index = 3)] emergency_cancel { ref_index : :: core :: primitive :: u32 , } , # [codec (index = 4)] external_propose { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 5)] external_propose_majority { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 6)] external_propose_default { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 7)] fast_track { proposal_hash : :: subxt :: sp_core :: H256 , voting_period : :: core :: primitive :: u32 , delay : :: core :: primitive :: u32 , } , # [codec (index = 8)] veto_external { proposal_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 9)] cancel_referendum { # [codec (compact)] ref_index : :: core :: primitive :: u32 , } , # [codec (index = 10)] cancel_queued { which : :: core :: primitive :: u32 , } , # [codec (index = 11)] delegate { to : :: subxt :: sp_core :: crypto :: AccountId32 , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , balance : :: core :: primitive :: u128 , } , # [codec (index = 12)] undelegate , # [codec (index = 13)] clear_public_proposals , # [codec (index = 14)] note_preimage { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 15)] note_preimage_operational { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 16)] note_imminent_preimage { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 17)] note_imminent_preimage_operational { encoded_proposal : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 18)] reap_preimage { proposal_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] proposal_len_upper_bound : :: core :: primitive :: u32 , } , # [codec (index = 19)] unlock { target : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 20)] remove_vote { index : :: core :: primitive :: u32 , } , # [codec (index = 21)] remove_other_vote { target : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 , } , # [codec (index = 22)] enact_proposal { proposal_hash : :: subxt :: sp_core :: H256 , index : :: core :: primitive :: u32 , } , # [codec (index = 23)] blacklist { proposal_hash : :: subxt :: sp_core :: H256 , maybe_ref_index : :: core :: option :: Option < :: core :: primitive :: u32 > , } , # [codec (index = 24)] cancel_proposal { # [codec (compact)] prop_index : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] ValueLow , # [codec (index = 1)] ProposalMissing , # [codec (index = 2)] AlreadyCanceled , # [codec (index = 3)] DuplicateProposal , # [codec (index = 4)] ProposalBlacklisted , # [codec (index = 5)] NotSimpleMajority , # [codec (index = 6)] InvalidHash , # [codec (index = 7)] NoProposal , # [codec (index = 8)] AlreadyVetoed , # [codec (index = 9)] DuplicatePreimage , # [codec (index = 10)] NotImminent , # [codec (index = 11)] TooEarly , # [codec (index = 12)] Imminent , # [codec (index = 13)] PreimageMissing , # [codec (index = 14)] ReferendumInvalid , # [codec (index = 15)] PreimageInvalid , # [codec (index = 16)] NoneWaiting , # [codec (index = 17)] NotVoter , # [codec (index = 18)] NoPermission , # [codec (index = 19)] AlreadyDelegating , # [codec (index = 20)] InsufficientFunds , # [codec (index = 21)] NotDelegating , # [codec (index = 22)] VotesExist , # [codec (index = 23)] InstantNotAllowed , # [codec (index = 24)] Nonsense , # [codec (index = 25)] WrongUpperBound , # [codec (index = 26)] MaxVotesReached , # [codec (index = 27)] TooManyProposals , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Proposed (:: core :: primitive :: u32 , :: core :: primitive :: u128 ,) , # [codec (index = 1)] Tabled (:: core :: primitive :: u32 , :: core :: primitive :: u128 , :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) , # [codec (index = 2)] ExternalTabled , # [codec (index = 3)] Started (:: core :: primitive :: u32 , runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold ,) , # [codec (index = 4)] Passed (:: core :: primitive :: u32 ,) , # [codec (index = 5)] NotPassed (:: core :: primitive :: u32 ,) , # [codec (index = 6)] Cancelled (:: core :: primitive :: u32 ,) , # [codec (index = 7)] Executed (:: core :: primitive :: u32 , :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ,) , # [codec (index = 8)] Delegated (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 9)] Undelegated (:: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 10)] Vetoed (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 ,) , # [codec (index = 11)] PreimageNoted (:: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 12)] PreimageUsed (:: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 13)] PreimageInvalid (:: subxt :: sp_core :: H256 , :: core :: primitive :: u32 ,) , # [codec (index = 14)] PreimageMissing (:: subxt :: sp_core :: H256 , :: core :: primitive :: u32 ,) , # [codec (index = 15)] PreimageReaped (:: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 16)] Blacklisted (:: subxt :: sp_core :: H256 ,) , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Delegations < _0 > { pub votes : _0 , pub capital : _0 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum ReferendumInfo < _0 , _1 , _2 > { # [codec (index = 0)] Ongoing (runtime_types :: pallet_democracy :: types :: ReferendumStatus < _0 , _1 , _2 > ,) , # [codec (index = 1)] Finished { approved : :: core :: primitive :: bool , end : _0 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ReferendumStatus < _0 , _1 , _2 > { pub end : _0 , pub proposal_hash : _1 , pub threshold : runtime_types :: pallet_democracy :: vote_threshold :: VoteThreshold , pub delay : _0 , pub tally : runtime_types :: pallet_democracy :: types :: Tally < _2 > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Tally < _0 > { pub ayes : _0 , pub nays : _0 , pub turnout : _0 , } } pub mod vote { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum AccountVote < _0 > { # [codec (index = 0)] Standard { vote : runtime_types :: pallet_democracy :: vote :: Vote , balance : _0 , } , # [codec (index = 1)] Split { aye : _0 , nay : _0 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct PriorLock < _0 , _1 > (pub _0 , pub _1 ,) ; # [derive (:: subxt :: codec :: CompactAs)] # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Vote (:: core :: primitive :: u8 ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Voting < _0 , _1 , _2 > { # [codec (index = 0)] Direct { votes : :: std :: vec :: Vec < (_2 , runtime_types :: pallet_democracy :: vote :: AccountVote < _0 > ,) > , delegations : runtime_types :: pallet_democracy :: types :: Delegations < _0 > , prior : runtime_types :: pallet_democracy :: vote :: PriorLock < _2 , _0 > , } , # [codec (index = 1)] Delegating { balance : _0 , target : _1 , conviction : runtime_types :: pallet_democracy :: conviction :: Conviction , delegations : runtime_types :: pallet_democracy :: types :: Delegations < _0 > , prior : runtime_types :: pallet_democracy :: vote :: PriorLock < _2 , _0 > , } , } } pub mod vote_threshold { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum VoteThreshold { # [codec (index = 0)] SuperMajorityApprove , # [codec (index = 1)] SuperMajorityAgainst , # [codec (index = 2)] SimpleMajority , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum PreimageStatus < _0 , _1 , _2 > { # [codec (index = 0)] Missing (_2 ,) , # [codec (index = 1)] Available { data : :: std :: vec :: Vec < :: core :: primitive :: u8 > , provider : _0 , deposit : _1 , since : _2 , expiry : :: core :: option :: Option < _2 > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Releases { # [codec (index = 0)] V1 , } } pub mod pallet_elections_phragmen { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] vote { votes : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] remove_voter , # [codec (index = 2)] submit_candidacy { # [codec (compact)] candidate_count : :: core :: primitive :: u32 , } , # [codec (index = 3)] renounce_candidacy { renouncing : runtime_types :: pallet_elections_phragmen :: Renouncing , } , # [codec (index = 4)] remove_member { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , has_replacement : :: core :: primitive :: bool , } , # [codec (index = 5)] clean_defunct_voters { num_voters : :: core :: primitive :: u32 , num_defunct : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] UnableToVote , # [codec (index = 1)] NoVotes , # [codec (index = 2)] TooManyVotes , # [codec (index = 3)] MaximumVotesExceeded , # [codec (index = 4)] LowBalance , # [codec (index = 5)] UnableToPayBond , # [codec (index = 6)] MustBeVoter , # [codec (index = 7)] ReportSelf , # [codec (index = 8)] DuplicatedCandidate , # [codec (index = 9)] MemberSubmit , # [codec (index = 10)] RunnerUpSubmit , # [codec (index = 11)] InsufficientCandidateFunds , # [codec (index = 12)] NotMember , # [codec (index = 13)] InvalidWitnessData , # [codec (index = 14)] InvalidVoteCount , # [codec (index = 15)] InvalidRenouncing , # [codec (index = 16)] InvalidReplacement , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] NewTerm (:: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > ,) , # [codec (index = 1)] EmptyTerm , # [codec (index = 2)] ElectionError , # [codec (index = 3)] MemberKicked (:: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 4)] Renounced (:: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 5)] CandidateSlashed (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 6)] SeatHolderSlashed (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Renouncing { # [codec (index = 0)] Member , # [codec (index = 1)] RunnerUp , # [codec (index = 2)] Candidate (:: core :: primitive :: u32 ,) , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct SeatHolder < _0 , _1 > { pub who : _0 , pub stake : _1 , pub deposit : _1 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Voter < _0 , _1 > { pub votes : :: std :: vec :: Vec < _0 > , pub stake : _1 , pub deposit : _1 , } } pub mod pallet_grandpa { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] report_equivocation { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 1)] report_equivocation_unsigned { equivocation_proof : :: std :: boxed :: Box < runtime_types :: sp_finality_grandpa :: EquivocationProof < :: subxt :: sp_core :: H256 , :: core :: primitive :: u32 > > , key_owner_proof : runtime_types :: sp_session :: MembershipProof , } , # [codec (index = 2)] note_stalled { delay : :: core :: primitive :: u32 , best_finalized_block_number : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] PauseFailed , # [codec (index = 1)] ResumeFailed , # [codec (index = 2)] ChangePending , # [codec (index = 3)] TooSoon , # [codec (index = 4)] InvalidKeyOwnershipProof , # [codec (index = 5)] InvalidEquivocationProof , # [codec (index = 6)] DuplicateOffenceReport , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] NewAuthorities (:: std :: vec :: Vec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > ,) , # [codec (index = 1)] Paused , # [codec (index = 2)] Resumed , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct StoredPendingChange < _0 > { pub scheduled_at : _0 , pub delay : _0 , pub next_authorities : runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < (runtime_types :: sp_finality_grandpa :: app :: Public , :: core :: primitive :: u64 ,) > , pub forced : :: core :: option :: Option < _0 > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum StoredState < _0 > { # [codec (index = 0)] Live , # [codec (index = 1)] PendingPause { scheduled_at : _0 , delay : _0 , } , # [codec (index = 2)] Paused , # [codec (index = 3)] PendingResume { scheduled_at : _0 , delay : _0 , } , } } pub mod pallet_identity { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] add_registrar { account : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 1)] set_identity { info : :: std :: boxed :: Box < runtime_types :: pallet_identity :: types :: IdentityInfo > , } , # [codec (index = 2)] set_subs { subs : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_identity :: types :: Data ,) > , } , # [codec (index = 3)] clear_identity , # [codec (index = 4)] request_judgement { # [codec (compact)] reg_index : :: core :: primitive :: u32 , # [codec (compact)] max_fee : :: core :: primitive :: u128 , } , # [codec (index = 5)] cancel_request { reg_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] set_fee { # [codec (compact)] index : :: core :: primitive :: u32 , # [codec (compact)] fee : :: core :: primitive :: u128 , } , # [codec (index = 7)] set_account_id { # [codec (compact)] index : :: core :: primitive :: u32 , new : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 8)] set_fields { # [codec (compact)] index : :: core :: primitive :: u32 , fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > , } , # [codec (index = 9)] provide_judgement { # [codec (compact)] reg_index : :: core :: primitive :: u32 , target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , judgement : runtime_types :: pallet_identity :: types :: Judgement < :: core :: primitive :: u128 > , } , # [codec (index = 10)] kill_identity { target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 11)] add_sub { sub : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , data : runtime_types :: pallet_identity :: types :: Data , } , # [codec (index = 12)] rename_sub { sub : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , data : runtime_types :: pallet_identity :: types :: Data , } , # [codec (index = 13)] remove_sub { sub : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 14)] quit_sub , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] TooManySubAccounts , # [codec (index = 1)] NotFound , # [codec (index = 2)] NotNamed , # [codec (index = 3)] EmptyIndex , # [codec (index = 4)] FeeChanged , # [codec (index = 5)] NoIdentity , # [codec (index = 6)] StickyJudgement , # [codec (index = 7)] JudgementGiven , # [codec (index = 8)] InvalidJudgement , # [codec (index = 9)] InvalidIndex , # [codec (index = 10)] InvalidTarget , # [codec (index = 11)] TooManyFields , # [codec (index = 12)] TooManyRegistrars , # [codec (index = 13)] AlreadyClaimed , # [codec (index = 14)] NotSub , # [codec (index = 15)] NotOwned , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] IdentitySet (:: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 1)] IdentityCleared (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 2)] IdentityKilled (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 3)] JudgementRequested (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 ,) , # [codec (index = 4)] JudgementUnrequested (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 ,) , # [codec (index = 5)] JudgementGiven (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 ,) , # [codec (index = 6)] RegistrarAdded (:: core :: primitive :: u32 ,) , # [codec (index = 7)] SubIdentityAdded (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 8)] SubIdentityRemoved (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 9)] SubIdentityRevoked (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs)] # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BitFlags < _0 > (pub :: core :: primitive :: u64 , # [codec (skip)] pub :: core :: marker :: PhantomData < _0 > ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Data { # [codec (index = 0)] None , # [codec (index = 1)] Raw0 ([:: core :: primitive :: u8 ; 0usize] ,) , # [codec (index = 2)] Raw1 ([:: core :: primitive :: u8 ; 1usize] ,) , # [codec (index = 3)] Raw2 ([:: core :: primitive :: u8 ; 2usize] ,) , # [codec (index = 4)] Raw3 ([:: core :: primitive :: u8 ; 3usize] ,) , # [codec (index = 5)] Raw4 ([:: core :: primitive :: u8 ; 4usize] ,) , # [codec (index = 6)] Raw5 ([:: core :: primitive :: u8 ; 5usize] ,) , # [codec (index = 7)] Raw6 ([:: core :: primitive :: u8 ; 6usize] ,) , # [codec (index = 8)] Raw7 ([:: core :: primitive :: u8 ; 7usize] ,) , # [codec (index = 9)] Raw8 ([:: core :: primitive :: u8 ; 8usize] ,) , # [codec (index = 10)] Raw9 ([:: core :: primitive :: u8 ; 9usize] ,) , # [codec (index = 11)] Raw10 ([:: core :: primitive :: u8 ; 10usize] ,) , # [codec (index = 12)] Raw11 ([:: core :: primitive :: u8 ; 11usize] ,) , # [codec (index = 13)] Raw12 ([:: core :: primitive :: u8 ; 12usize] ,) , # [codec (index = 14)] Raw13 ([:: core :: primitive :: u8 ; 13usize] ,) , # [codec (index = 15)] Raw14 ([:: core :: primitive :: u8 ; 14usize] ,) , # [codec (index = 16)] Raw15 ([:: core :: primitive :: u8 ; 15usize] ,) , # [codec (index = 17)] Raw16 ([:: core :: primitive :: u8 ; 16usize] ,) , # [codec (index = 18)] Raw17 ([:: core :: primitive :: u8 ; 17usize] ,) , # [codec (index = 19)] Raw18 ([:: core :: primitive :: u8 ; 18usize] ,) , # [codec (index = 20)] Raw19 ([:: core :: primitive :: u8 ; 19usize] ,) , # [codec (index = 21)] Raw20 ([:: core :: primitive :: u8 ; 20usize] ,) , # [codec (index = 22)] Raw21 ([:: core :: primitive :: u8 ; 21usize] ,) , # [codec (index = 23)] Raw22 ([:: core :: primitive :: u8 ; 22usize] ,) , # [codec (index = 24)] Raw23 ([:: core :: primitive :: u8 ; 23usize] ,) , # [codec (index = 25)] Raw24 ([:: core :: primitive :: u8 ; 24usize] ,) , # [codec (index = 26)] Raw25 ([:: core :: primitive :: u8 ; 25usize] ,) , # [codec (index = 27)] Raw26 ([:: core :: primitive :: u8 ; 26usize] ,) , # [codec (index = 28)] Raw27 ([:: core :: primitive :: u8 ; 27usize] ,) , # [codec (index = 29)] Raw28 ([:: core :: primitive :: u8 ; 28usize] ,) , # [codec (index = 30)] Raw29 ([:: core :: primitive :: u8 ; 29usize] ,) , # [codec (index = 31)] Raw30 ([:: core :: primitive :: u8 ; 30usize] ,) , # [codec (index = 32)] Raw31 ([:: core :: primitive :: u8 ; 31usize] ,) , # [codec (index = 33)] Raw32 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 34)] BlakeTwo256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 35)] Sha256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 36)] Keccak256 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 37)] ShaThree256 ([:: core :: primitive :: u8 ; 32usize] ,) , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum IdentityField { # [codec (index = 1)] Display , # [codec (index = 2)] Legal , # [codec (index = 4)] Web , # [codec (index = 8)] Riot , # [codec (index = 16)] Email , # [codec (index = 32)] PgpFingerprint , # [codec (index = 64)] Image , # [codec (index = 128)] Twitter , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct IdentityInfo { pub additional : runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < (runtime_types :: pallet_identity :: types :: Data , runtime_types :: pallet_identity :: types :: Data ,) > , pub display : runtime_types :: pallet_identity :: types :: Data , pub legal : runtime_types :: pallet_identity :: types :: Data , pub web : runtime_types :: pallet_identity :: types :: Data , pub riot : runtime_types :: pallet_identity :: types :: Data , pub email : runtime_types :: pallet_identity :: types :: Data , pub pgp_fingerprint : :: core :: option :: Option < [:: core :: primitive :: u8 ; 20usize] > , pub image : runtime_types :: pallet_identity :: types :: Data , pub twitter : runtime_types :: pallet_identity :: types :: Data , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Judgement < _0 > { # [codec (index = 0)] Unknown , # [codec (index = 1)] FeePaid (_0 ,) , # [codec (index = 2)] Reasonable , # [codec (index = 3)] KnownGood , # [codec (index = 4)] OutOfDate , # [codec (index = 5)] LowQuality , # [codec (index = 6)] Erroneous , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RegistrarInfo < _0 , _1 > { pub account : _1 , pub fee : _0 , pub fields : runtime_types :: pallet_identity :: types :: BitFlags < runtime_types :: pallet_identity :: types :: IdentityField > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Registration < _0 > { pub judgements : runtime_types :: frame_support :: storage :: bounded_vec :: BoundedVec < (:: core :: primitive :: u32 , runtime_types :: pallet_identity :: types :: Judgement < _0 > ,) > , pub deposit : _0 , pub info : runtime_types :: pallet_identity :: types :: IdentityInfo , } } } pub mod pallet_im_online { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] heartbeat { heartbeat : runtime_types :: pallet_im_online :: Heartbeat < :: core :: primitive :: u32 > , signature : runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Signature , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InvalidKey , # [codec (index = 1)] DuplicatedHeartbeat , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] HeartbeatReceived (runtime_types :: pallet_im_online :: sr25519 :: app_sr25519 :: Public ,) , # [codec (index = 1)] AllGood , # [codec (index = 2)] SomeOffline (:: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 ,) > ,) , } } pub mod sr25519 { use super :: runtime_types ; pub mod app_sr25519 { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Public (pub runtime_types :: sp_core :: sr25519 :: Public ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Signature (pub runtime_types :: sp_core :: sr25519 :: Signature ,) ; } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BoundedOpaqueNetworkState { pub peer_id : runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < :: core :: primitive :: u8 > , pub external_addresses : runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < runtime_types :: frame_support :: storage :: weak_bounded_vec :: WeakBoundedVec < :: core :: primitive :: u8 > > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Heartbeat < _0 > { pub block_number : _0 , pub network_state : runtime_types :: sp_core :: offchain :: OpaqueNetworkState , pub session_index : _0 , pub authority_index : _0 , pub validators_len : _0 , } } pub mod pallet_indices { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] claim { index : :: core :: primitive :: u32 , } , # [codec (index = 1)] transfer { new : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] free { index : :: core :: primitive :: u32 , } , # [codec (index = 3)] force_transfer { new : :: subxt :: sp_core :: crypto :: AccountId32 , index : :: core :: primitive :: u32 , freeze : :: core :: primitive :: bool , } , # [codec (index = 4)] freeze { index : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] NotAssigned , # [codec (index = 1)] NotOwner , # [codec (index = 2)] InUse , # [codec (index = 3)] NotTransfer , # [codec (index = 4)] Permanent , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] IndexAssigned (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 ,) , # [codec (index = 1)] IndexFreed (:: core :: primitive :: u32 ,) , # [codec (index = 2)] IndexFrozen (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 ,) , } } } pub mod pallet_membership { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] add_member { who : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 1)] remove_member { who : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 2)] swap_member { remove : :: subxt :: sp_core :: crypto :: AccountId32 , add : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 3)] reset_members { members : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 4)] change_key { new : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 5)] set_prime { who : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 6)] clear_prime , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] AlreadyMember , # [codec (index = 1)] NotMember , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] MemberAdded , # [codec (index = 1)] MemberRemoved , # [codec (index = 2)] MembersSwapped , # [codec (index = 3)] MembersReset , # [codec (index = 4)] KeyChanged , # [codec (index = 5)] Dummy , } } } pub mod pallet_multisig { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] as_multi_threshold_1 { other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , } , # [codec (index = 1)] as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call : :: std :: vec :: Vec < :: core :: primitive :: u8 > , store_call : :: core :: primitive :: bool , max_weight : :: core :: primitive :: u64 , } , # [codec (index = 2)] approve_as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , maybe_timepoint : :: core :: option :: Option < runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > > , call_hash : [:: core :: primitive :: u8 ; 32usize] , max_weight : :: core :: primitive :: u64 , } , # [codec (index = 3)] cancel_as_multi { threshold : :: core :: primitive :: u16 , other_signatories : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , timepoint : runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , call_hash : [:: core :: primitive :: u8 ; 32usize] , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] MinimumThreshold , # [codec (index = 1)] AlreadyApproved , # [codec (index = 2)] NoApprovalsNeeded , # [codec (index = 3)] TooFewSignatories , # [codec (index = 4)] TooManySignatories , # [codec (index = 5)] SignatoriesOutOfOrder , # [codec (index = 6)] SenderInSignatories , # [codec (index = 7)] NotFound , # [codec (index = 8)] NotOwner , # [codec (index = 9)] NoTimepoint , # [codec (index = 10)] WrongTimepoint , # [codec (index = 11)] UnexpectedTimepoint , # [codec (index = 12)] MaxWeightTooLow , # [codec (index = 13)] AlreadyStored , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] NewMultisig (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , [:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 1)] MultisigApproval (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , :: subxt :: sp_core :: crypto :: AccountId32 , [:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 2)] MultisigExecuted (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , :: subxt :: sp_core :: crypto :: AccountId32 , [:: core :: primitive :: u8 ; 32usize] , :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ,) , # [codec (index = 3)] MultisigCancelled (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: pallet_multisig :: Timepoint < :: core :: primitive :: u32 > , :: subxt :: sp_core :: crypto :: AccountId32 , [:: core :: primitive :: u8 ; 32usize] ,) , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Multisig < _0 , _1 , _2 > { pub when : runtime_types :: pallet_multisig :: Timepoint < _0 > , pub deposit : _1 , pub depositor : _2 , pub approvals : :: std :: vec :: Vec < _2 > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Timepoint < _0 > { pub height : _0 , pub index : _0 , } } pub mod pallet_offences { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Offence ([:: core :: primitive :: u8 ; 16usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , } } } pub mod pallet_proxy { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] proxy { real : :: subxt :: sp_core :: crypto :: AccountId32 , force_proxy_type : :: core :: option :: Option < runtime_types :: dev_runtime :: ProxyType > , call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , } , # [codec (index = 1)] add_proxy { delegate : :: subxt :: sp_core :: crypto :: AccountId32 , proxy_type : runtime_types :: dev_runtime :: ProxyType , delay : :: core :: primitive :: u32 , } , # [codec (index = 2)] remove_proxy { delegate : :: subxt :: sp_core :: crypto :: AccountId32 , proxy_type : runtime_types :: dev_runtime :: ProxyType , delay : :: core :: primitive :: u32 , } , # [codec (index = 3)] remove_proxies , # [codec (index = 4)] anonymous { proxy_type : runtime_types :: dev_runtime :: ProxyType , delay : :: core :: primitive :: u32 , index : :: core :: primitive :: u16 , } , # [codec (index = 5)] kill_anonymous { spawner : :: subxt :: sp_core :: crypto :: AccountId32 , proxy_type : runtime_types :: dev_runtime :: ProxyType , index : :: core :: primitive :: u16 , # [codec (compact)] height : :: core :: primitive :: u32 , # [codec (compact)] ext_index : :: core :: primitive :: u32 , } , # [codec (index = 6)] announce { real : :: subxt :: sp_core :: crypto :: AccountId32 , call_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 7)] remove_announcement { real : :: subxt :: sp_core :: crypto :: AccountId32 , call_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 8)] reject_announcement { delegate : :: subxt :: sp_core :: crypto :: AccountId32 , call_hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 9)] proxy_announced { delegate : :: subxt :: sp_core :: crypto :: AccountId32 , real : :: subxt :: sp_core :: crypto :: AccountId32 , force_proxy_type : :: core :: option :: Option < runtime_types :: dev_runtime :: ProxyType > , call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] TooMany , # [codec (index = 1)] NotFound , # [codec (index = 2)] NotProxy , # [codec (index = 3)] Unproxyable , # [codec (index = 4)] Duplicate , # [codec (index = 5)] NoPermission , # [codec (index = 6)] Unannounced , # [codec (index = 7)] NoSelfProxy , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] ProxyExecuted (:: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ,) , # [codec (index = 1)] AnonymousCreated (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: dev_runtime :: ProxyType , :: core :: primitive :: u16 ,) , # [codec (index = 2)] Announced (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: H256 ,) , # [codec (index = 3)] ProxyAdded (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: dev_runtime :: ProxyType , :: core :: primitive :: u32 ,) , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Announcement < _0 , _1 , _2 > { pub real : _0 , pub call_hash : _1 , pub height : _2 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ProxyDefinition < _0 , _1 , _2 > { pub delegate : _0 , pub proxy_type : _1 , pub delay : _2 , } } pub mod pallet_scheduler { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] schedule { when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , } , # [codec (index = 1)] cancel { when : :: core :: primitive :: u32 , index : :: core :: primitive :: u32 , } , # [codec (index = 2)] schedule_named { id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , when : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , } , # [codec (index = 3)] cancel_named { id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] schedule_after { after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , } , # [codec (index = 5)] schedule_named_after { id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , after : :: core :: primitive :: u32 , maybe_periodic : :: core :: option :: Option < (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) > , priority : :: core :: primitive :: u8 , call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] FailedToSchedule , # [codec (index = 1)] NotFound , # [codec (index = 2)] TargetBlockNumberInPast , # [codec (index = 3)] RescheduleNoChange , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Scheduled (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , # [codec (index = 1)] Canceled (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , # [codec (index = 2)] Dispatched ((:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , :: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ,) , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Releases { # [codec (index = 0)] V1 , # [codec (index = 1)] V2 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ScheduledV2 < _0 , _1 , _2 , _3 > { pub maybe_id : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub priority : :: core :: primitive :: u8 , pub call : _0 , pub maybe_periodic : :: core :: option :: Option < (_1 , _1 ,) > , pub origin : _2 , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _3 > , } } pub mod pallet_session { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] set_keys { keys : runtime_types :: dev_runtime :: SessionKeys , proof : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] purge_keys , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InvalidProof , # [codec (index = 1)] NoAssociatedValidatorId , # [codec (index = 2)] DuplicatedKey , # [codec (index = 3)] NoKeys , # [codec (index = 4)] NoAccount , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] NewSession (:: core :: primitive :: u32 ,) , } } } pub mod pallet_sudo { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] sudo { call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , } , # [codec (index = 1)] sudo_unchecked_weight { call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , weight : :: core :: primitive :: u64 , } , # [codec (index = 2)] set_key { new : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 3)] sudo_as { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] RequireSudo , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Sudid (:: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ,) , # [codec (index = 1)] KeyChanged (:: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 2)] SudoAsDone (:: core :: result :: Result < () , runtime_types :: sp_runtime :: DispatchError > ,) , } } } pub mod pallet_timestamp { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] set { # [codec (compact)] now : :: core :: primitive :: u64 , } , } } } pub mod pallet_tips { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] report_awesome { reason : :: std :: vec :: Vec < :: core :: primitive :: u8 > , who : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 1)] retract_tip { hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 2)] tip_new { reason : :: std :: vec :: Vec < :: core :: primitive :: u8 > , who : :: subxt :: sp_core :: crypto :: AccountId32 , # [codec (compact)] tip_value : :: core :: primitive :: u128 , } , # [codec (index = 3)] tip { hash : :: subxt :: sp_core :: H256 , # [codec (compact)] tip_value : :: core :: primitive :: u128 , } , # [codec (index = 4)] close_tip { hash : :: subxt :: sp_core :: H256 , } , # [codec (index = 5)] slash_tip { hash : :: subxt :: sp_core :: H256 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] ReasonTooBig , # [codec (index = 1)] AlreadyKnown , # [codec (index = 2)] UnknownTip , # [codec (index = 3)] NotFinder , # [codec (index = 4)] StillOpen , # [codec (index = 5)] Premature , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] NewTip (:: subxt :: sp_core :: H256 ,) , # [codec (index = 1)] TipClosing (:: subxt :: sp_core :: H256 ,) , # [codec (index = 2)] TipClosed (:: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 3)] TipRetracted (:: subxt :: sp_core :: H256 ,) , # [codec (index = 4)] TipSlashed (:: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct OpenTip < _0 , _1 , _2 , _3 > { pub reason : _3 , pub who : _0 , pub finder : _0 , pub deposit : _1 , pub closes : :: core :: option :: Option < _2 > , pub tips : :: std :: vec :: Vec < (_0 , _1 ,) > , pub finders_fee : :: core :: primitive :: bool , } } pub mod pallet_transaction_payment { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ChargeTransactionPayment (pub :: core :: primitive :: u128 ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Releases { # [codec (index = 0)] V1Ancient , # [codec (index = 1)] V2 , } } pub mod pallet_treasury { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] propose_spend { # [codec (compact)] value : :: core :: primitive :: u128 , beneficiary : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 1)] reject_proposal { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , # [codec (index = 2)] approve_proposal { # [codec (compact)] proposal_id : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InsufficientProposersBalance , # [codec (index = 1)] InvalidIndex , # [codec (index = 2)] TooManyApprovals , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Proposed (:: core :: primitive :: u32 ,) , # [codec (index = 1)] Spending (:: core :: primitive :: u128 ,) , # [codec (index = 2)] Awarded (:: core :: primitive :: u32 , :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 3)] Rejected (:: core :: primitive :: u32 , :: core :: primitive :: u128 ,) , # [codec (index = 4)] Burnt (:: core :: primitive :: u128 ,) , # [codec (index = 5)] Rollover (:: core :: primitive :: u128 ,) , # [codec (index = 6)] Deposit (:: core :: primitive :: u128 ,) , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Proposal < _0 , _1 > { pub proposer : _0 , pub value : _1 , pub beneficiary : _0 , pub bond : _1 , } } pub mod pallet_utility { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] batch { calls : :: std :: vec :: Vec < runtime_types :: dev_runtime :: Call > , } , # [codec (index = 1)] as_derivative { index : :: core :: primitive :: u16 , call : :: std :: boxed :: Box < runtime_types :: dev_runtime :: Call > , } , # [codec (index = 2)] batch_all { calls : :: std :: vec :: Vec < runtime_types :: dev_runtime :: Call > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] TooManyCalls , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] BatchInterrupted (:: core :: primitive :: u32 , runtime_types :: sp_runtime :: DispatchError ,) , # [codec (index = 1)] BatchCompleted , # [codec (index = 2)] ItemCompleted , } } } pub mod primitive_types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct H256 (pub [:: core :: primitive :: u8 ; 32usize] ,) ; } pub mod sp_arithmetic { use super :: runtime_types ; pub mod fixed_point { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs)] # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct FixedU128 (pub :: core :: primitive :: u128 ,) ; } pub mod per_things { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs)] # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Perbill (pub :: core :: primitive :: u32 ,) ; # [derive (:: subxt :: codec :: CompactAs)] # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Percent (pub :: core :: primitive :: u8 ,) ; # [derive (:: subxt :: codec :: CompactAs)] # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Permill (pub :: core :: primitive :: u32 ,) ; } } pub mod sp_authority_discovery { use super :: runtime_types ; pub mod app { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Public (pub runtime_types :: sp_core :: sr25519 :: Public ,) ; } } pub mod sp_consensus_babe { use super :: runtime_types ; pub mod app { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Public (pub runtime_types :: sp_core :: sr25519 :: Public ,) ; } pub mod digests { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum NextConfigDescriptor { # [codec (index = 1)] V1 { c : (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) , allowed_slots : runtime_types :: sp_consensus_babe :: AllowedSlots , } , } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum AllowedSlots { # [codec (index = 0)] PrimarySlots , # [codec (index = 1)] PrimaryAndSecondaryPlainSlots , # [codec (index = 2)] PrimaryAndSecondaryVRFSlots , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BabeEpochConfiguration { pub c : (:: core :: primitive :: u64 , :: core :: primitive :: u64 ,) , pub allowed_slots : runtime_types :: sp_consensus_babe :: AllowedSlots , } } pub mod sp_consensus_slots { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct EquivocationProof < _0 , _1 > { pub offender : _1 , pub slot : runtime_types :: sp_consensus_slots :: Slot , pub first_header : _0 , pub second_header : _0 , } # [derive (:: subxt :: codec :: CompactAs)] # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Slot (pub :: core :: primitive :: u64 ,) ; } pub mod sp_core { use super :: runtime_types ; pub mod changes_trie { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ChangesTrieConfiguration { pub digest_interval : :: core :: primitive :: u32 , pub digest_levels : :: core :: primitive :: u32 , } } pub mod crypto { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AccountId32 (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct KeyTypeId (pub [:: core :: primitive :: u8 ; 4usize] ,) ; } pub mod ecdsa { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Signature (pub [:: core :: primitive :: u8 ; 65usize] ,) ; } pub mod ed25519 { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Signature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; } pub mod offchain { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct OpaqueMultiaddr (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct OpaqueNetworkState { pub peer_id : runtime_types :: sp_core :: OpaquePeerId , pub external_addresses : :: std :: vec :: Vec < runtime_types :: sp_core :: offchain :: OpaqueMultiaddr > , } } pub mod sr25519 { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Public (pub [:: core :: primitive :: u8 ; 32usize] ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Signature (pub [:: core :: primitive :: u8 ; 64usize] ,) ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct OpaquePeerId (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Void { } } pub mod sp_finality_grandpa { use super :: runtime_types ; pub mod app { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Public (pub runtime_types :: sp_core :: ed25519 :: Public ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Signature (pub runtime_types :: sp_core :: ed25519 :: Signature ,) ; } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Equivocation < _0 , _1 > { # [codec (index = 0)] Prevote (runtime_types :: finality_grandpa :: Equivocation < runtime_types :: sp_finality_grandpa :: app :: Public , runtime_types :: finality_grandpa :: Prevote < _0 , _1 > , runtime_types :: sp_finality_grandpa :: app :: Signature > ,) , # [codec (index = 1)] Precommit (runtime_types :: finality_grandpa :: Equivocation < runtime_types :: sp_finality_grandpa :: app :: Public , runtime_types :: finality_grandpa :: Precommit < _0 , _1 > , runtime_types :: sp_finality_grandpa :: app :: Signature > ,) , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct EquivocationProof < _0 , _1 > { pub set_id : :: core :: primitive :: u64 , pub equivocation : runtime_types :: sp_finality_grandpa :: Equivocation < _0 , _1 > , } } pub mod sp_runtime { use super :: runtime_types ; pub mod generic { use super :: runtime_types ; pub mod digest { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum ChangesTrieSignal { # [codec (index = 0)] NewConfiguration (:: core :: option :: Option < runtime_types :: sp_core :: changes_trie :: ChangesTrieConfiguration > ,) , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Digest < _0 > { pub logs : :: std :: vec :: Vec < runtime_types :: sp_runtime :: generic :: digest :: DigestItem < _0 > > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum DigestItem < _0 > { # [codec (index = 2)] ChangesTrieRoot (_0 ,) , # [codec (index = 6)] PreRuntime ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 4)] Consensus ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 5)] Seal ([:: core :: primitive :: u8 ; 4usize] , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 7)] ChangesTrieSignal (runtime_types :: sp_runtime :: generic :: digest :: ChangesTrieSignal ,) , # [codec (index = 0)] Other (:: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 8)] RuntimeEnvironmentUpdated , } } pub mod era { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Era { # [codec (index = 0)] Immortal , # [codec (index = 1)] Mortal1 (:: core :: primitive :: u8 ,) , # [codec (index = 2)] Mortal2 (:: core :: primitive :: u8 ,) , # [codec (index = 3)] Mortal3 (:: core :: primitive :: u8 ,) , # [codec (index = 4)] Mortal4 (:: core :: primitive :: u8 ,) , # [codec (index = 5)] Mortal5 (:: core :: primitive :: u8 ,) , # [codec (index = 6)] Mortal6 (:: core :: primitive :: u8 ,) , # [codec (index = 7)] Mortal7 (:: core :: primitive :: u8 ,) , # [codec (index = 8)] Mortal8 (:: core :: primitive :: u8 ,) , # [codec (index = 9)] Mortal9 (:: core :: primitive :: u8 ,) , # [codec (index = 10)] Mortal10 (:: core :: primitive :: u8 ,) , # [codec (index = 11)] Mortal11 (:: core :: primitive :: u8 ,) , # [codec (index = 12)] Mortal12 (:: core :: primitive :: u8 ,) , # [codec (index = 13)] Mortal13 (:: core :: primitive :: u8 ,) , # [codec (index = 14)] Mortal14 (:: core :: primitive :: u8 ,) , # [codec (index = 15)] Mortal15 (:: core :: primitive :: u8 ,) , # [codec (index = 16)] Mortal16 (:: core :: primitive :: u8 ,) , # [codec (index = 17)] Mortal17 (:: core :: primitive :: u8 ,) , # [codec (index = 18)] Mortal18 (:: core :: primitive :: u8 ,) , # [codec (index = 19)] Mortal19 (:: core :: primitive :: u8 ,) , # [codec (index = 20)] Mortal20 (:: core :: primitive :: u8 ,) , # [codec (index = 21)] Mortal21 (:: core :: primitive :: u8 ,) , # [codec (index = 22)] Mortal22 (:: core :: primitive :: u8 ,) , # [codec (index = 23)] Mortal23 (:: core :: primitive :: u8 ,) , # [codec (index = 24)] Mortal24 (:: core :: primitive :: u8 ,) , # [codec (index = 25)] Mortal25 (:: core :: primitive :: u8 ,) , # [codec (index = 26)] Mortal26 (:: core :: primitive :: u8 ,) , # [codec (index = 27)] Mortal27 (:: core :: primitive :: u8 ,) , # [codec (index = 28)] Mortal28 (:: core :: primitive :: u8 ,) , # [codec (index = 29)] Mortal29 (:: core :: primitive :: u8 ,) , # [codec (index = 30)] Mortal30 (:: core :: primitive :: u8 ,) , # [codec (index = 31)] Mortal31 (:: core :: primitive :: u8 ,) , # [codec (index = 32)] Mortal32 (:: core :: primitive :: u8 ,) , # [codec (index = 33)] Mortal33 (:: core :: primitive :: u8 ,) , # [codec (index = 34)] Mortal34 (:: core :: primitive :: u8 ,) , # [codec (index = 35)] Mortal35 (:: core :: primitive :: u8 ,) , # [codec (index = 36)] Mortal36 (:: core :: primitive :: u8 ,) , # [codec (index = 37)] Mortal37 (:: core :: primitive :: u8 ,) , # [codec (index = 38)] Mortal38 (:: core :: primitive :: u8 ,) , # [codec (index = 39)] Mortal39 (:: core :: primitive :: u8 ,) , # [codec (index = 40)] Mortal40 (:: core :: primitive :: u8 ,) , # [codec (index = 41)] Mortal41 (:: core :: primitive :: u8 ,) , # [codec (index = 42)] Mortal42 (:: core :: primitive :: u8 ,) , # [codec (index = 43)] Mortal43 (:: core :: primitive :: u8 ,) , # [codec (index = 44)] Mortal44 (:: core :: primitive :: u8 ,) , # [codec (index = 45)] Mortal45 (:: core :: primitive :: u8 ,) , # [codec (index = 46)] Mortal46 (:: core :: primitive :: u8 ,) , # [codec (index = 47)] Mortal47 (:: core :: primitive :: u8 ,) , # [codec (index = 48)] Mortal48 (:: core :: primitive :: u8 ,) , # [codec (index = 49)] Mortal49 (:: core :: primitive :: u8 ,) , # [codec (index = 50)] Mortal50 (:: core :: primitive :: u8 ,) , # [codec (index = 51)] Mortal51 (:: core :: primitive :: u8 ,) , # [codec (index = 52)] Mortal52 (:: core :: primitive :: u8 ,) , # [codec (index = 53)] Mortal53 (:: core :: primitive :: u8 ,) , # [codec (index = 54)] Mortal54 (:: core :: primitive :: u8 ,) , # [codec (index = 55)] Mortal55 (:: core :: primitive :: u8 ,) , # [codec (index = 56)] Mortal56 (:: core :: primitive :: u8 ,) , # [codec (index = 57)] Mortal57 (:: core :: primitive :: u8 ,) , # [codec (index = 58)] Mortal58 (:: core :: primitive :: u8 ,) , # [codec (index = 59)] Mortal59 (:: core :: primitive :: u8 ,) , # [codec (index = 60)] Mortal60 (:: core :: primitive :: u8 ,) , # [codec (index = 61)] Mortal61 (:: core :: primitive :: u8 ,) , # [codec (index = 62)] Mortal62 (:: core :: primitive :: u8 ,) , # [codec (index = 63)] Mortal63 (:: core :: primitive :: u8 ,) , # [codec (index = 64)] Mortal64 (:: core :: primitive :: u8 ,) , # [codec (index = 65)] Mortal65 (:: core :: primitive :: u8 ,) , # [codec (index = 66)] Mortal66 (:: core :: primitive :: u8 ,) , # [codec (index = 67)] Mortal67 (:: core :: primitive :: u8 ,) , # [codec (index = 68)] Mortal68 (:: core :: primitive :: u8 ,) , # [codec (index = 69)] Mortal69 (:: core :: primitive :: u8 ,) , # [codec (index = 70)] Mortal70 (:: core :: primitive :: u8 ,) , # [codec (index = 71)] Mortal71 (:: core :: primitive :: u8 ,) , # [codec (index = 72)] Mortal72 (:: core :: primitive :: u8 ,) , # [codec (index = 73)] Mortal73 (:: core :: primitive :: u8 ,) , # [codec (index = 74)] Mortal74 (:: core :: primitive :: u8 ,) , # [codec (index = 75)] Mortal75 (:: core :: primitive :: u8 ,) , # [codec (index = 76)] Mortal76 (:: core :: primitive :: u8 ,) , # [codec (index = 77)] Mortal77 (:: core :: primitive :: u8 ,) , # [codec (index = 78)] Mortal78 (:: core :: primitive :: u8 ,) , # [codec (index = 79)] Mortal79 (:: core :: primitive :: u8 ,) , # [codec (index = 80)] Mortal80 (:: core :: primitive :: u8 ,) , # [codec (index = 81)] Mortal81 (:: core :: primitive :: u8 ,) , # [codec (index = 82)] Mortal82 (:: core :: primitive :: u8 ,) , # [codec (index = 83)] Mortal83 (:: core :: primitive :: u8 ,) , # [codec (index = 84)] Mortal84 (:: core :: primitive :: u8 ,) , # [codec (index = 85)] Mortal85 (:: core :: primitive :: u8 ,) , # [codec (index = 86)] Mortal86 (:: core :: primitive :: u8 ,) , # [codec (index = 87)] Mortal87 (:: core :: primitive :: u8 ,) , # [codec (index = 88)] Mortal88 (:: core :: primitive :: u8 ,) , # [codec (index = 89)] Mortal89 (:: core :: primitive :: u8 ,) , # [codec (index = 90)] Mortal90 (:: core :: primitive :: u8 ,) , # [codec (index = 91)] Mortal91 (:: core :: primitive :: u8 ,) , # [codec (index = 92)] Mortal92 (:: core :: primitive :: u8 ,) , # [codec (index = 93)] Mortal93 (:: core :: primitive :: u8 ,) , # [codec (index = 94)] Mortal94 (:: core :: primitive :: u8 ,) , # [codec (index = 95)] Mortal95 (:: core :: primitive :: u8 ,) , # [codec (index = 96)] Mortal96 (:: core :: primitive :: u8 ,) , # [codec (index = 97)] Mortal97 (:: core :: primitive :: u8 ,) , # [codec (index = 98)] Mortal98 (:: core :: primitive :: u8 ,) , # [codec (index = 99)] Mortal99 (:: core :: primitive :: u8 ,) , # [codec (index = 100)] Mortal100 (:: core :: primitive :: u8 ,) , # [codec (index = 101)] Mortal101 (:: core :: primitive :: u8 ,) , # [codec (index = 102)] Mortal102 (:: core :: primitive :: u8 ,) , # [codec (index = 103)] Mortal103 (:: core :: primitive :: u8 ,) , # [codec (index = 104)] Mortal104 (:: core :: primitive :: u8 ,) , # [codec (index = 105)] Mortal105 (:: core :: primitive :: u8 ,) , # [codec (index = 106)] Mortal106 (:: core :: primitive :: u8 ,) , # [codec (index = 107)] Mortal107 (:: core :: primitive :: u8 ,) , # [codec (index = 108)] Mortal108 (:: core :: primitive :: u8 ,) , # [codec (index = 109)] Mortal109 (:: core :: primitive :: u8 ,) , # [codec (index = 110)] Mortal110 (:: core :: primitive :: u8 ,) , # [codec (index = 111)] Mortal111 (:: core :: primitive :: u8 ,) , # [codec (index = 112)] Mortal112 (:: core :: primitive :: u8 ,) , # [codec (index = 113)] Mortal113 (:: core :: primitive :: u8 ,) , # [codec (index = 114)] Mortal114 (:: core :: primitive :: u8 ,) , # [codec (index = 115)] Mortal115 (:: core :: primitive :: u8 ,) , # [codec (index = 116)] Mortal116 (:: core :: primitive :: u8 ,) , # [codec (index = 117)] Mortal117 (:: core :: primitive :: u8 ,) , # [codec (index = 118)] Mortal118 (:: core :: primitive :: u8 ,) , # [codec (index = 119)] Mortal119 (:: core :: primitive :: u8 ,) , # [codec (index = 120)] Mortal120 (:: core :: primitive :: u8 ,) , # [codec (index = 121)] Mortal121 (:: core :: primitive :: u8 ,) , # [codec (index = 122)] Mortal122 (:: core :: primitive :: u8 ,) , # [codec (index = 123)] Mortal123 (:: core :: primitive :: u8 ,) , # [codec (index = 124)] Mortal124 (:: core :: primitive :: u8 ,) , # [codec (index = 125)] Mortal125 (:: core :: primitive :: u8 ,) , # [codec (index = 126)] Mortal126 (:: core :: primitive :: u8 ,) , # [codec (index = 127)] Mortal127 (:: core :: primitive :: u8 ,) , # [codec (index = 128)] Mortal128 (:: core :: primitive :: u8 ,) , # [codec (index = 129)] Mortal129 (:: core :: primitive :: u8 ,) , # [codec (index = 130)] Mortal130 (:: core :: primitive :: u8 ,) , # [codec (index = 131)] Mortal131 (:: core :: primitive :: u8 ,) , # [codec (index = 132)] Mortal132 (:: core :: primitive :: u8 ,) , # [codec (index = 133)] Mortal133 (:: core :: primitive :: u8 ,) , # [codec (index = 134)] Mortal134 (:: core :: primitive :: u8 ,) , # [codec (index = 135)] Mortal135 (:: core :: primitive :: u8 ,) , # [codec (index = 136)] Mortal136 (:: core :: primitive :: u8 ,) , # [codec (index = 137)] Mortal137 (:: core :: primitive :: u8 ,) , # [codec (index = 138)] Mortal138 (:: core :: primitive :: u8 ,) , # [codec (index = 139)] Mortal139 (:: core :: primitive :: u8 ,) , # [codec (index = 140)] Mortal140 (:: core :: primitive :: u8 ,) , # [codec (index = 141)] Mortal141 (:: core :: primitive :: u8 ,) , # [codec (index = 142)] Mortal142 (:: core :: primitive :: u8 ,) , # [codec (index = 143)] Mortal143 (:: core :: primitive :: u8 ,) , # [codec (index = 144)] Mortal144 (:: core :: primitive :: u8 ,) , # [codec (index = 145)] Mortal145 (:: core :: primitive :: u8 ,) , # [codec (index = 146)] Mortal146 (:: core :: primitive :: u8 ,) , # [codec (index = 147)] Mortal147 (:: core :: primitive :: u8 ,) , # [codec (index = 148)] Mortal148 (:: core :: primitive :: u8 ,) , # [codec (index = 149)] Mortal149 (:: core :: primitive :: u8 ,) , # [codec (index = 150)] Mortal150 (:: core :: primitive :: u8 ,) , # [codec (index = 151)] Mortal151 (:: core :: primitive :: u8 ,) , # [codec (index = 152)] Mortal152 (:: core :: primitive :: u8 ,) , # [codec (index = 153)] Mortal153 (:: core :: primitive :: u8 ,) , # [codec (index = 154)] Mortal154 (:: core :: primitive :: u8 ,) , # [codec (index = 155)] Mortal155 (:: core :: primitive :: u8 ,) , # [codec (index = 156)] Mortal156 (:: core :: primitive :: u8 ,) , # [codec (index = 157)] Mortal157 (:: core :: primitive :: u8 ,) , # [codec (index = 158)] Mortal158 (:: core :: primitive :: u8 ,) , # [codec (index = 159)] Mortal159 (:: core :: primitive :: u8 ,) , # [codec (index = 160)] Mortal160 (:: core :: primitive :: u8 ,) , # [codec (index = 161)] Mortal161 (:: core :: primitive :: u8 ,) , # [codec (index = 162)] Mortal162 (:: core :: primitive :: u8 ,) , # [codec (index = 163)] Mortal163 (:: core :: primitive :: u8 ,) , # [codec (index = 164)] Mortal164 (:: core :: primitive :: u8 ,) , # [codec (index = 165)] Mortal165 (:: core :: primitive :: u8 ,) , # [codec (index = 166)] Mortal166 (:: core :: primitive :: u8 ,) , # [codec (index = 167)] Mortal167 (:: core :: primitive :: u8 ,) , # [codec (index = 168)] Mortal168 (:: core :: primitive :: u8 ,) , # [codec (index = 169)] Mortal169 (:: core :: primitive :: u8 ,) , # [codec (index = 170)] Mortal170 (:: core :: primitive :: u8 ,) , # [codec (index = 171)] Mortal171 (:: core :: primitive :: u8 ,) , # [codec (index = 172)] Mortal172 (:: core :: primitive :: u8 ,) , # [codec (index = 173)] Mortal173 (:: core :: primitive :: u8 ,) , # [codec (index = 174)] Mortal174 (:: core :: primitive :: u8 ,) , # [codec (index = 175)] Mortal175 (:: core :: primitive :: u8 ,) , # [codec (index = 176)] Mortal176 (:: core :: primitive :: u8 ,) , # [codec (index = 177)] Mortal177 (:: core :: primitive :: u8 ,) , # [codec (index = 178)] Mortal178 (:: core :: primitive :: u8 ,) , # [codec (index = 179)] Mortal179 (:: core :: primitive :: u8 ,) , # [codec (index = 180)] Mortal180 (:: core :: primitive :: u8 ,) , # [codec (index = 181)] Mortal181 (:: core :: primitive :: u8 ,) , # [codec (index = 182)] Mortal182 (:: core :: primitive :: u8 ,) , # [codec (index = 183)] Mortal183 (:: core :: primitive :: u8 ,) , # [codec (index = 184)] Mortal184 (:: core :: primitive :: u8 ,) , # [codec (index = 185)] Mortal185 (:: core :: primitive :: u8 ,) , # [codec (index = 186)] Mortal186 (:: core :: primitive :: u8 ,) , # [codec (index = 187)] Mortal187 (:: core :: primitive :: u8 ,) , # [codec (index = 188)] Mortal188 (:: core :: primitive :: u8 ,) , # [codec (index = 189)] Mortal189 (:: core :: primitive :: u8 ,) , # [codec (index = 190)] Mortal190 (:: core :: primitive :: u8 ,) , # [codec (index = 191)] Mortal191 (:: core :: primitive :: u8 ,) , # [codec (index = 192)] Mortal192 (:: core :: primitive :: u8 ,) , # [codec (index = 193)] Mortal193 (:: core :: primitive :: u8 ,) , # [codec (index = 194)] Mortal194 (:: core :: primitive :: u8 ,) , # [codec (index = 195)] Mortal195 (:: core :: primitive :: u8 ,) , # [codec (index = 196)] Mortal196 (:: core :: primitive :: u8 ,) , # [codec (index = 197)] Mortal197 (:: core :: primitive :: u8 ,) , # [codec (index = 198)] Mortal198 (:: core :: primitive :: u8 ,) , # [codec (index = 199)] Mortal199 (:: core :: primitive :: u8 ,) , # [codec (index = 200)] Mortal200 (:: core :: primitive :: u8 ,) , # [codec (index = 201)] Mortal201 (:: core :: primitive :: u8 ,) , # [codec (index = 202)] Mortal202 (:: core :: primitive :: u8 ,) , # [codec (index = 203)] Mortal203 (:: core :: primitive :: u8 ,) , # [codec (index = 204)] Mortal204 (:: core :: primitive :: u8 ,) , # [codec (index = 205)] Mortal205 (:: core :: primitive :: u8 ,) , # [codec (index = 206)] Mortal206 (:: core :: primitive :: u8 ,) , # [codec (index = 207)] Mortal207 (:: core :: primitive :: u8 ,) , # [codec (index = 208)] Mortal208 (:: core :: primitive :: u8 ,) , # [codec (index = 209)] Mortal209 (:: core :: primitive :: u8 ,) , # [codec (index = 210)] Mortal210 (:: core :: primitive :: u8 ,) , # [codec (index = 211)] Mortal211 (:: core :: primitive :: u8 ,) , # [codec (index = 212)] Mortal212 (:: core :: primitive :: u8 ,) , # [codec (index = 213)] Mortal213 (:: core :: primitive :: u8 ,) , # [codec (index = 214)] Mortal214 (:: core :: primitive :: u8 ,) , # [codec (index = 215)] Mortal215 (:: core :: primitive :: u8 ,) , # [codec (index = 216)] Mortal216 (:: core :: primitive :: u8 ,) , # [codec (index = 217)] Mortal217 (:: core :: primitive :: u8 ,) , # [codec (index = 218)] Mortal218 (:: core :: primitive :: u8 ,) , # [codec (index = 219)] Mortal219 (:: core :: primitive :: u8 ,) , # [codec (index = 220)] Mortal220 (:: core :: primitive :: u8 ,) , # [codec (index = 221)] Mortal221 (:: core :: primitive :: u8 ,) , # [codec (index = 222)] Mortal222 (:: core :: primitive :: u8 ,) , # [codec (index = 223)] Mortal223 (:: core :: primitive :: u8 ,) , # [codec (index = 224)] Mortal224 (:: core :: primitive :: u8 ,) , # [codec (index = 225)] Mortal225 (:: core :: primitive :: u8 ,) , # [codec (index = 226)] Mortal226 (:: core :: primitive :: u8 ,) , # [codec (index = 227)] Mortal227 (:: core :: primitive :: u8 ,) , # [codec (index = 228)] Mortal228 (:: core :: primitive :: u8 ,) , # [codec (index = 229)] Mortal229 (:: core :: primitive :: u8 ,) , # [codec (index = 230)] Mortal230 (:: core :: primitive :: u8 ,) , # [codec (index = 231)] Mortal231 (:: core :: primitive :: u8 ,) , # [codec (index = 232)] Mortal232 (:: core :: primitive :: u8 ,) , # [codec (index = 233)] Mortal233 (:: core :: primitive :: u8 ,) , # [codec (index = 234)] Mortal234 (:: core :: primitive :: u8 ,) , # [codec (index = 235)] Mortal235 (:: core :: primitive :: u8 ,) , # [codec (index = 236)] Mortal236 (:: core :: primitive :: u8 ,) , # [codec (index = 237)] Mortal237 (:: core :: primitive :: u8 ,) , # [codec (index = 238)] Mortal238 (:: core :: primitive :: u8 ,) , # [codec (index = 239)] Mortal239 (:: core :: primitive :: u8 ,) , # [codec (index = 240)] Mortal240 (:: core :: primitive :: u8 ,) , # [codec (index = 241)] Mortal241 (:: core :: primitive :: u8 ,) , # [codec (index = 242)] Mortal242 (:: core :: primitive :: u8 ,) , # [codec (index = 243)] Mortal243 (:: core :: primitive :: u8 ,) , # [codec (index = 244)] Mortal244 (:: core :: primitive :: u8 ,) , # [codec (index = 245)] Mortal245 (:: core :: primitive :: u8 ,) , # [codec (index = 246)] Mortal246 (:: core :: primitive :: u8 ,) , # [codec (index = 247)] Mortal247 (:: core :: primitive :: u8 ,) , # [codec (index = 248)] Mortal248 (:: core :: primitive :: u8 ,) , # [codec (index = 249)] Mortal249 (:: core :: primitive :: u8 ,) , # [codec (index = 250)] Mortal250 (:: core :: primitive :: u8 ,) , # [codec (index = 251)] Mortal251 (:: core :: primitive :: u8 ,) , # [codec (index = 252)] Mortal252 (:: core :: primitive :: u8 ,) , # [codec (index = 253)] Mortal253 (:: core :: primitive :: u8 ,) , # [codec (index = 254)] Mortal254 (:: core :: primitive :: u8 ,) , # [codec (index = 255)] Mortal255 (:: core :: primitive :: u8 ,) , } } pub mod header { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Header < _0 , _1 > { pub parent_hash : :: subxt :: sp_core :: H256 , # [codec (compact)] pub number : _0 , pub state_root : :: subxt :: sp_core :: H256 , pub extrinsics_root : :: subxt :: sp_core :: H256 , pub digest : runtime_types :: sp_runtime :: generic :: digest :: Digest < :: subxt :: sp_core :: H256 > , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _1 > , } } pub mod unchecked_extrinsic { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct UncheckedExtrinsic < _0 , _1 , _2 , _3 > (:: std :: vec :: Vec < :: core :: primitive :: u8 > , # [codec (skip)] pub :: core :: marker :: PhantomData < (_1 , _0 , _2 , _3) > ,) ; } } pub mod multiaddress { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum MultiAddress < _0 , _1 > { # [codec (index = 0)] Id (_0 ,) , # [codec (index = 1)] Index (_1 ,) , # [codec (index = 2)] Raw (:: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 3)] Address32 ([:: core :: primitive :: u8 ; 32usize] ,) , # [codec (index = 4)] Address20 ([:: core :: primitive :: u8 ; 20usize] ,) , } } pub mod traits { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BlakeTwo256 { } } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum ArithmeticError { # [codec (index = 0)] Underflow , # [codec (index = 1)] Overflow , # [codec (index = 2)] DivisionByZero , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum DispatchError { # [codec (index = 0)] Other , # [codec (index = 1)] CannotLookup , # [codec (index = 2)] BadOrigin , # [codec (index = 3)] Module { index : :: core :: primitive :: u8 , error : :: core :: primitive :: u8 , } , # [codec (index = 4)] ConsumerRemaining , # [codec (index = 5)] NoProviders , # [codec (index = 6)] Token (runtime_types :: sp_runtime :: TokenError ,) , # [codec (index = 7)] Arithmetic (runtime_types :: sp_runtime :: ArithmeticError ,) , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum MultiSignature { # [codec (index = 0)] Ed25519 (runtime_types :: sp_core :: ed25519 :: Signature ,) , # [codec (index = 1)] Sr25519 (runtime_types :: sp_core :: sr25519 :: Signature ,) , # [codec (index = 2)] Ecdsa (runtime_types :: sp_core :: ecdsa :: Signature ,) , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum TokenError { # [codec (index = 0)] NoFunds , # [codec (index = 1)] WouldDie , # [codec (index = 2)] BelowMinimum , # [codec (index = 3)] CannotCreate , # [codec (index = 4)] UnknownAsset , # [codec (index = 5)] Frozen , # [codec (index = 6)] Unsupported , } } pub mod sp_session { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MembershipProof { pub session : :: core :: primitive :: u32 , pub trie_nodes : :: std :: vec :: Vec < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , pub validator_count : :: core :: primitive :: u32 , } } pub mod sp_staking { use super :: runtime_types ; pub mod offence { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct OffenceDetails < _0 , _1 > { pub offender : _1 , pub reporters : :: std :: vec :: Vec < _0 > , } } } pub mod sp_version { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct RuntimeVersion { pub spec_name : :: std :: string :: String , pub impl_name : :: std :: string :: String , pub authoring_version : :: core :: primitive :: u32 , pub spec_version : :: core :: primitive :: u32 , pub impl_version : :: core :: primitive :: u32 , pub apis : :: std :: vec :: Vec < ([:: core :: primitive :: u8 ; 8usize] , :: core :: primitive :: u32 ,) > , pub transaction_version : :: core :: primitive :: u32 , } } pub mod xp_assets_registrar { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Chain { # [codec (index = 0)] ChainX , # [codec (index = 1)] Bitcoin , # [codec (index = 2)] Ethereum , # [codec (index = 3)] Polkadot , } } pub mod xp_gateway_bitcoin { use super :: runtime_types ; pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum BtcTxType { # [codec (index = 0)] Withdrawal , # [codec (index = 1)] Deposit , # [codec (index = 2)] HotAndCold , # [codec (index = 3)] TrusteeTransition , # [codec (index = 4)] Irrelevance , } } } pub mod xp_protocol { use super :: runtime_types ; pub mod network { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum NetworkType { # [codec (index = 0)] Mainnet , # [codec (index = 1)] Testnet , } } } pub mod xp_runtime { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Memo (pub :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) ; } pub mod xpallet_assets { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] transfer { dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] id : :: core :: primitive :: u32 , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] force_transfer { transactor : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , dest : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] id : :: core :: primitive :: u32 , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 2)] set_balance { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] id : :: core :: primitive :: u32 , balances : :: std :: collections :: BTreeMap < runtime_types :: xpallet_assets :: types :: AssetType , :: core :: primitive :: u128 > , } , # [codec (index = 3)] set_asset_limit { # [codec (compact)] id : :: core :: primitive :: u32 , restrictions : runtime_types :: xpallet_assets :: types :: AssetRestrictions , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InvalidAsset , # [codec (index = 1)] Overflow , # [codec (index = 2)] InsufficientBalance , # [codec (index = 3)] LiquidityRestrictions , # [codec (index = 4)] AmountIntoBalanceFailed , # [codec (index = 5)] TotalAssetOverflow , # [codec (index = 6)] TotalAssetInsufficientBalance , # [codec (index = 7)] DenyNativeAsset , # [codec (index = 8)] ActionNotAllowed , # [codec (index = 9)] StillHasActiveReserved , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Moved (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: xpallet_assets :: types :: AssetType , :: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: xpallet_assets :: types :: AssetType , :: core :: primitive :: u128 ,) , # [codec (index = 1)] Issued (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 2)] Destroyed (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 3)] BalanceSet (:: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: xpallet_assets :: types :: AssetType , :: core :: primitive :: u128 ,) , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: CompactAs)] # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AssetRestrictions { pub bits : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum AssetType { # [codec (index = 0)] Usable , # [codec (index = 1)] Locked , # [codec (index = 2)] Reserved , # [codec (index = 3)] ReservedWithdrawal , # [codec (index = 4)] ReservedDexSpot , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BalanceLock < _0 > { pub id : [:: core :: primitive :: u8 ; 8usize] , pub amount : _0 , } } } pub mod xpallet_assets_registrar { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] register { # [codec (compact)] asset_id : :: core :: primitive :: u32 , asset : runtime_types :: xpallet_assets_registrar :: types :: AssetInfo , is_online : :: core :: primitive :: bool , has_mining_rights : :: core :: primitive :: bool , } , # [codec (index = 1)] deregister { # [codec (compact)] id : :: core :: primitive :: u32 , } , # [codec (index = 2)] recover { # [codec (compact)] id : :: core :: primitive :: u32 , has_mining_rights : :: core :: primitive :: bool , } , # [codec (index = 3)] update_asset_info { # [codec (compact)] id : :: core :: primitive :: u32 , token : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , token_name : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , desc : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InvalidAssetTokenSymbolLength , # [codec (index = 1)] InvalidAssetTokenSymbolChar , # [codec (index = 2)] InvalidAssetTokenNameLength , # [codec (index = 3)] InvalidAssetDescLength , # [codec (index = 4)] InvalidAscii , # [codec (index = 5)] AssetAlreadyExists , # [codec (index = 6)] AssetDoesNotExist , # [codec (index = 7)] AssetAlreadyValid , # [codec (index = 8)] AssetIsInvalid , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Registered (:: core :: primitive :: u32 , :: core :: primitive :: bool ,) , # [codec (index = 1)] Recovered (:: core :: primitive :: u32 , :: core :: primitive :: bool ,) , # [codec (index = 2)] Deregistered (:: core :: primitive :: u32 ,) , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AssetInfo { pub token : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub token_name : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub chain : runtime_types :: xp_assets_registrar :: Chain , pub decimals : :: core :: primitive :: u8 , pub desc : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } } } pub mod xpallet_dex_spot { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] put_order { # [codec (compact)] pair_id : :: core :: primitive :: u32 , order_type : runtime_types :: xpallet_dex_spot :: types :: OrderType , side : runtime_types :: xpallet_dex_spot :: types :: Side , # [codec (compact)] amount : :: core :: primitive :: u128 , # [codec (compact)] price : :: core :: primitive :: u128 , } , # [codec (index = 1)] cancel_order { # [codec (compact)] pair_id : :: core :: primitive :: u32 , # [codec (compact)] order_id : :: core :: primitive :: u64 , } , # [codec (index = 2)] force_cancel_order { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] pair_id : :: core :: primitive :: u32 , # [codec (compact)] order_id : :: core :: primitive :: u64 , } , # [codec (index = 3)] set_handicap { # [codec (compact)] pair_id : :: core :: primitive :: u32 , new : runtime_types :: xpallet_dex_spot :: types :: Handicap < :: core :: primitive :: u128 > , } , # [codec (index = 4)] set_price_fluctuation { # [codec (compact)] pair_id : :: core :: primitive :: u32 , # [codec (compact)] new : :: core :: primitive :: u32 , } , # [codec (index = 5)] add_trading_pair { currency_pair : runtime_types :: xpallet_dex_spot :: types :: CurrencyPair , # [codec (compact)] pip_decimals : :: core :: primitive :: u32 , # [codec (compact)] tick_decimals : :: core :: primitive :: u32 , # [codec (compact)] latest_price : :: core :: primitive :: u128 , tradable : :: core :: primitive :: bool , } , # [codec (index = 6)] update_trading_pair { # [codec (compact)] pair_id : :: core :: primitive :: u32 , # [codec (compact)] tick_decimals : :: core :: primitive :: u32 , tradable : :: core :: primitive :: bool , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InvalidPrice , # [codec (index = 1)] TooHighBidPrice , # [codec (index = 2)] TooLowAskPrice , # [codec (index = 3)] VolumeTooSmall , # [codec (index = 4)] ZeroAmount , # [codec (index = 5)] InsufficientBalance , # [codec (index = 6)] InvalidOrderType , # [codec (index = 7)] InvalidTradingPair , # [codec (index = 8)] TradingPairUntradable , # [codec (index = 9)] NonexistentTradingPair , # [codec (index = 10)] InvalidTickdecimals , # [codec (index = 11)] InvalidPriceVolatility , # [codec (index = 12)] TradingPairAlreadyExists , # [codec (index = 13)] TooManyBacklogOrders , # [codec (index = 14)] InvalidTradingPairAsset , # [codec (index = 15)] CancelOrderNotAllowed , # [codec (index = 16)] InvalidOrderId , # [codec (index = 17)] AssetError , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] NewOrder (runtime_types :: xpallet_dex_spot :: types :: Order < :: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ,) , # [codec (index = 1)] MakerOrderUpdated (runtime_types :: xpallet_dex_spot :: types :: Order < :: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ,) , # [codec (index = 2)] TakerOrderUpdated (runtime_types :: xpallet_dex_spot :: types :: Order < :: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ,) , # [codec (index = 3)] OrderExecuted (runtime_types :: xpallet_dex_spot :: types :: OrderExecutedInfo < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 , :: core :: primitive :: u128 > ,) , # [codec (index = 4)] CanceledOrderUpdated (runtime_types :: xpallet_dex_spot :: types :: Order < :: core :: primitive :: u32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ,) , # [codec (index = 5)] TradingPairAdded (runtime_types :: xpallet_dex_spot :: types :: TradingPairProfile ,) , # [codec (index = 6)] TradingPairUpdated (runtime_types :: xpallet_dex_spot :: types :: TradingPairProfile ,) , # [codec (index = 7)] PriceFluctuationUpdated (:: core :: primitive :: u32 , :: core :: primitive :: u32 ,) , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct CurrencyPair { pub base : :: core :: primitive :: u32 , pub quote : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Handicap < _0 > { pub highest_bid : _0 , pub lowest_ask : _0 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Order < _0 , _1 , _2 , _3 , _4 > { pub props : runtime_types :: xpallet_dex_spot :: types :: OrderProperty < _0 , _1 , _2 , _2 , _0 > , pub status : runtime_types :: xpallet_dex_spot :: types :: OrderStatus , pub remaining : _2 , pub executed_indices : :: std :: vec :: Vec < :: core :: primitive :: u64 > , pub already_filled : _2 , pub last_update_at : _0 , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < (_4 , _3) > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct OrderExecutedInfo < _0 , _1 , _2 , _3 > { pub trading_history_idx : :: core :: primitive :: u64 , pub pair_id : _2 , pub price : _1 , pub maker : _0 , pub taker : _0 , pub maker_order_id : :: core :: primitive :: u64 , pub taker_order_id : :: core :: primitive :: u64 , pub turnover : _1 , pub executed_at : _2 , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _3 > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct OrderProperty < _0 , _1 , _2 , _3 , _4 > { pub id : :: core :: primitive :: u64 , pub side : runtime_types :: xpallet_dex_spot :: types :: Side , pub price : _2 , pub amount : _2 , pub pair_id : _0 , pub submitter : _1 , pub order_type : runtime_types :: xpallet_dex_spot :: types :: OrderType , pub created_at : _0 , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < (_4 , _3) > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum OrderStatus { # [codec (index = 0)] Created , # [codec (index = 1)] PartialFill , # [codec (index = 2)] Filled , # [codec (index = 3)] PartialFillAndCanceled , # [codec (index = 4)] Canceled , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum OrderType { # [codec (index = 0)] Limit , # [codec (index = 1)] Market , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Side { # [codec (index = 0)] Buy , # [codec (index = 1)] Sell , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TradingPairInfo < _0 , _1 > { pub latest_price : _0 , pub last_updated : _1 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TradingPairProfile { pub id : :: core :: primitive :: u32 , pub currency_pair : runtime_types :: xpallet_dex_spot :: types :: CurrencyPair , pub pip_decimals : :: core :: primitive :: u32 , pub tick_decimals : :: core :: primitive :: u32 , pub tradable : :: core :: primitive :: bool , } } } pub mod xpallet_gateway_bitcoin { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] push_header { header : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 1)] push_transaction { raw_tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > , relayed_info : runtime_types :: xpallet_gateway_bitcoin :: types :: BtcRelayedTxInfo , prev_tx : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } , # [codec (index = 2)] create_withdraw_tx { withdrawal_id_list : :: std :: vec :: Vec < :: core :: primitive :: u32 > , tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 3)] create_taproot_withdraw_tx { withdrawal_id_list : :: std :: vec :: Vec < :: core :: primitive :: u32 > , tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > , spent_outputs : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 4)] sign_withdraw_tx { tx : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , } , # [codec (index = 5)] set_best_index { index : runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderIndex , } , # [codec (index = 6)] set_confirmed_index { index : runtime_types :: xpallet_gateway_bitcoin :: types :: BtcHeaderIndex , } , # [codec (index = 7)] remove_pending { addr : :: std :: vec :: Vec < :: core :: primitive :: u8 > , who : :: core :: option :: Option < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 8)] remove_proposal , # [codec (index = 9)] force_replace_proposal_tx { tx : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 10)] set_btc_withdrawal_fee { # [codec (compact)] fee : :: core :: primitive :: u64 , } , # [codec (index = 11)] set_btc_deposit_limit { # [codec (compact)] value : :: core :: primitive :: u64 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InvalidBase58 , # [codec (index = 1)] InvalidAddr , # [codec (index = 2)] InvalidBestIndex , # [codec (index = 3)] InvalidPoW , # [codec (index = 4)] AncientFork , # [codec (index = 5)] InvalidPrevTx , # [codec (index = 6)] HeaderFuturisticTimestamp , # [codec (index = 7)] HeaderNBitsNotMatch , # [codec (index = 8)] HeaderUnknownParent , # [codec (index = 9)] HeaderNotFound , # [codec (index = 10)] HeaderAncientFork , # [codec (index = 11)] ExistingHeader , # [codec (index = 12)] PrevHeaderNotExisted , # [codec (index = 13)] DeserializeErr , # [codec (index = 14)] BadMerkleProof , # [codec (index = 15)] UnconfirmedTx , # [codec (index = 16)] ReplayedTx , # [codec (index = 17)] ProcessTxFailed , # [codec (index = 18)] MismatchedTx , # [codec (index = 19)] InvalidAddress , # [codec (index = 20)] VerifySignFailed , # [codec (index = 21)] InvalidSignCount , # [codec (index = 22)] InvalidPublicKey , # [codec (index = 23)] ConstructBadSign , # [codec (index = 24)] BadSignature , # [codec (index = 25)] BadRedeemScript , # [codec (index = 26)] NotTrustee , # [codec (index = 27)] DuplicatedKeys , # [codec (index = 28)] GenerateMultisigFailed , # [codec (index = 29)] InvalidTrusteeCount , # [codec (index = 30)] WroungWithdrawalCount , # [codec (index = 31)] RejectSig , # [codec (index = 32)] NoProposal , # [codec (index = 33)] InvalidProposal , # [codec (index = 34)] NotFinishProposal , # [codec (index = 35)] NoWithdrawalRecord , # [codec (index = 36)] DuplicateVote , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] HeaderInserted (:: subxt :: sp_core :: H256 ,) , # [codec (index = 1)] TxProcessed (:: subxt :: sp_core :: H256 , :: subxt :: sp_core :: H256 , runtime_types :: xpallet_gateway_bitcoin :: types :: BtcTxState ,) , # [codec (index = 2)] Deposited (:: subxt :: sp_core :: H256 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 3)] Withdrawn (:: subxt :: sp_core :: H256 , :: std :: vec :: Vec < :: core :: primitive :: u32 > , :: core :: primitive :: u128 ,) , # [codec (index = 4)] UnclaimedDeposit (:: subxt :: sp_core :: H256 , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 5)] PendingDepositRemoved (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: subxt :: sp_core :: H256 , :: std :: vec :: Vec < :: core :: primitive :: u8 > ,) , # [codec (index = 6)] WithdrawalProposalCreated (:: subxt :: sp_core :: crypto :: AccountId32 , :: std :: vec :: Vec < :: core :: primitive :: u32 > ,) , # [codec (index = 7)] WithdrawalProposalVoted (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: bool ,) , # [codec (index = 8)] WithdrawalProposalDropped (:: core :: primitive :: u32 , :: core :: primitive :: u32 , :: std :: vec :: Vec < :: core :: primitive :: u32 > ,) , # [codec (index = 9)] WithdrawalProposalCompleted (:: subxt :: sp_core :: H256 ,) , # [codec (index = 10)] WithdrawalFatalErr (:: subxt :: sp_core :: H256 , :: subxt :: sp_core :: H256 ,) , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BtcDepositCache { pub txid : :: subxt :: sp_core :: H256 , pub balance : :: core :: primitive :: u64 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BtcHeaderIndex { pub hash : :: subxt :: sp_core :: H256 , pub height : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BtcHeaderInfo { pub header : runtime_types :: light_bitcoin_chain :: block_header :: BlockHeader , pub height : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BtcParams { pub max_bits : :: core :: primitive :: u32 , pub block_max_future : :: core :: primitive :: u32 , pub target_timespan_seconds : :: core :: primitive :: u32 , pub target_spacing_seconds : :: core :: primitive :: u32 , pub retargeting_factor : :: core :: primitive :: u32 , pub retargeting_interval : :: core :: primitive :: u32 , pub min_timespan : :: core :: primitive :: u32 , pub max_timespan : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BtcRelayedTxInfo { pub block_hash : :: subxt :: sp_core :: H256 , pub merkle_proof : runtime_types :: light_bitcoin_merkle :: PartialMerkleTree , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum BtcTxResult { # [codec (index = 0)] Success , # [codec (index = 1)] Failure , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BtcTxState { pub tx_type : runtime_types :: xp_gateway_bitcoin :: types :: BtcTxType , pub result : runtime_types :: xpallet_gateway_bitcoin :: types :: BtcTxResult , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum BtcTxVerifier { # [codec (index = 0)] Recover , # [codec (index = 1)] RuntimeInterface , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BtcWithdrawalProposal < _0 > { pub sig_state : runtime_types :: xpallet_gateway_bitcoin :: types :: VoteResult , pub withdrawal_id_list : :: std :: vec :: Vec < :: core :: primitive :: u32 > , pub tx : runtime_types :: light_bitcoin_chain :: transaction :: Transaction , pub trustee_list : :: std :: vec :: Vec < (_0 , :: core :: primitive :: bool ,) > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum VoteResult { # [codec (index = 0)] Unfinish , # [codec (index = 1)] Finish , } } } pub mod xpallet_gateway_common { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] withdraw { # [codec (compact)] asset_id : :: core :: primitive :: u32 , # [codec (compact)] value : :: core :: primitive :: u128 , addr : :: std :: vec :: Vec < :: core :: primitive :: u8 > , ext : runtime_types :: xp_runtime :: Memo , } , # [codec (index = 1)] cancel_withdrawal { id : :: core :: primitive :: u32 , } , # [codec (index = 2)] setup_trustee { chain : runtime_types :: xp_assets_registrar :: Chain , about : :: std :: vec :: Vec < :: core :: primitive :: u8 > , hot_entity : :: std :: vec :: Vec < :: core :: primitive :: u8 > , cold_entity : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } , # [codec (index = 3)] transition_trustee_session { chain : runtime_types :: xp_assets_registrar :: Chain , new_trustees : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 4)] set_withdrawal_state { # [codec (compact)] id : :: core :: primitive :: u32 , state : runtime_types :: xpallet_gateway_records :: types :: WithdrawalState , } , # [codec (index = 5)] set_trustee_info_config { chain : runtime_types :: xp_assets_registrar :: Chain , config : runtime_types :: xpallet_gateway_common :: types :: TrusteeInfoConfig , } , # [codec (index = 6)] force_set_referral_binding { chain : runtime_types :: xp_assets_registrar :: Chain , who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , referral : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] InvalidWithdrawal , # [codec (index = 1)] InvalidGenericData , # [codec (index = 2)] InvalidTrusteeSession , # [codec (index = 3)] InvalidAboutLen , # [codec (index = 4)] InvalidMultisig , # [codec (index = 5)] NotSupportedChain , # [codec (index = 6)] DuplicatedAccountId , # [codec (index = 7)] NotRegistered , # [codec (index = 8)] NotValidator , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] SetTrusteeProps (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: xp_assets_registrar :: Chain , runtime_types :: xpallet_gateway_common :: types :: GenericTrusteeIntentionProps ,) , # [codec (index = 1)] ReferralBinded (:: subxt :: sp_core :: crypto :: AccountId32 , runtime_types :: xp_assets_registrar :: Chain , :: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 2)] TrusteeSetChanged (runtime_types :: xp_assets_registrar :: Chain , :: core :: primitive :: u32 , runtime_types :: xpallet_gateway_common :: types :: GenericTrusteeSessionInfo < :: subxt :: sp_core :: crypto :: AccountId32 > ,) , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct GenericTrusteeIntentionProps (pub runtime_types :: xpallet_gateway_common :: types :: TrusteeIntentionProps < :: std :: vec :: Vec < :: core :: primitive :: u8 > > ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct GenericTrusteeSessionInfo < _0 > (pub runtime_types :: xpallet_gateway_common :: types :: TrusteeSessionInfo < _0 , :: std :: vec :: Vec < :: core :: primitive :: u8 > > ,) ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TrusteeInfoConfig { pub min_trustee_count : :: core :: primitive :: u32 , pub max_trustee_count : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TrusteeIntentionProps < _0 > { pub about : _0 , pub hot_entity : _0 , pub cold_entity : _0 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct TrusteeSessionInfo < _0 , _1 > { pub trustee_list : :: std :: vec :: Vec < _0 > , pub threshold : :: core :: primitive :: u16 , pub hot_address : _1 , pub cold_address : _1 , } } } pub mod xpallet_gateway_records { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] root_deposit { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] asset_id : :: core :: primitive :: u32 , # [codec (compact)] balance : :: core :: primitive :: u128 , } , # [codec (index = 1)] root_withdraw { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] asset_id : :: core :: primitive :: u32 , # [codec (compact)] balance : :: core :: primitive :: u128 , addr : :: std :: vec :: Vec < :: core :: primitive :: u8 > , memo : runtime_types :: xp_runtime :: Memo , } , # [codec (index = 2)] set_withdrawal_state { # [codec (compact)] withdrawal_id : :: core :: primitive :: u32 , state : runtime_types :: xpallet_gateway_records :: types :: WithdrawalState , } , # [codec (index = 3)] set_withdrawal_state_list { item : :: std :: vec :: Vec < (:: core :: primitive :: u32 , runtime_types :: xpallet_gateway_records :: types :: WithdrawalState ,) > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] NotExisted , # [codec (index = 1)] NotApplyingState , # [codec (index = 2)] NotProcessingState , # [codec (index = 3)] InvalidAccount , # [codec (index = 4)] InvalidState , # [codec (index = 5)] UnexpectedChain , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Deposited (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 , :: core :: primitive :: u128 ,) , # [codec (index = 1)] WithdrawalCreated (:: core :: primitive :: u32 , runtime_types :: xpallet_gateway_records :: types :: WithdrawalRecord < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: core :: primitive :: u32 > ,) , # [codec (index = 2)] WithdrawalProcessed (:: core :: primitive :: u32 ,) , # [codec (index = 3)] WithdrawalRecovered (:: core :: primitive :: u32 ,) , # [codec (index = 4)] WithdrawalCanceled (:: core :: primitive :: u32 , runtime_types :: xpallet_gateway_records :: types :: WithdrawalState ,) , # [codec (index = 5)] WithdrawalFinished (:: core :: primitive :: u32 , runtime_types :: xpallet_gateway_records :: types :: WithdrawalState ,) , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct WithdrawalRecord < _0 , _1 , _2 > { pub asset_id : _2 , pub applicant : _0 , pub balance : _1 , pub addr : :: std :: vec :: Vec < :: core :: primitive :: u8 > , pub ext : runtime_types :: xp_runtime :: Memo , pub height : _2 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum WithdrawalState { # [codec (index = 0)] Applying , # [codec (index = 1)] Processing , # [codec (index = 2)] NormalFinish , # [codec (index = 3)] RootFinish , # [codec (index = 4)] NormalCancel , # [codec (index = 5)] RootCancel , } } } pub mod xpallet_mining_asset { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] claim { # [codec (compact)] target : :: core :: primitive :: u32 , } , # [codec (index = 1)] set_claim_staking_requirement { # [codec (compact)] asset_id : :: core :: primitive :: u32 , # [codec (compact)] new : :: core :: primitive :: u32 , } , # [codec (index = 2)] set_claim_frequency_limit { # [codec (compact)] asset_id : :: core :: primitive :: u32 , # [codec (compact)] new : :: core :: primitive :: u32 , } , # [codec (index = 3)] set_asset_power { # [codec (compact)] asset_id : :: core :: primitive :: u32 , # [codec (compact)] new : :: core :: primitive :: u32 , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] NotPrevilegedAsset , # [codec (index = 1)] InsufficientStaking , # [codec (index = 2)] UnexpiredFrequencyLimit , # [codec (index = 3)] ZeroMiningWeight , # [codec (index = 4)] DispatchError , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Claimed (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 , :: core :: primitive :: u128 ,) , # [codec (index = 1)] Minted (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct AssetLedger < _0 , _1 > { pub last_total_mining_weight : _0 , pub last_total_mining_weight_update : _1 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ClaimRestriction < _0 > { pub staking_requirement : _0 , pub frequency_limit : _0 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MinerLedger < _0 , _1 > { pub last_mining_weight : _0 , pub last_mining_weight_update : _1 , pub last_claim : :: core :: option :: Option < _1 > , } } } pub mod xpallet_mining_staking { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] bond { target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 1)] rebond { from : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , to : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 2)] unbond { target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] value : :: core :: primitive :: u128 , } , # [codec (index = 3)] unlock_unbonded_withdrawal { target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , # [codec (compact)] unbonded_index : :: core :: primitive :: u32 , } , # [codec (index = 4)] claim { target : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , } , # [codec (index = 5)] validate , # [codec (index = 6)] chill , # [codec (index = 7)] register { validator_nickname : :: std :: vec :: Vec < :: core :: primitive :: u8 > , # [codec (compact)] initial_bond : :: core :: primitive :: u128 , } , # [codec (index = 8)] set_validator_count { # [codec (compact)] new : :: core :: primitive :: u32 , } , # [codec (index = 9)] set_minimum_validator_count { # [codec (compact)] new : :: core :: primitive :: u32 , } , # [codec (index = 10)] set_bonding_duration { # [codec (compact)] new : :: core :: primitive :: u32 , } , # [codec (index = 11)] set_validator_bonding_duration { # [codec (compact)] new : :: core :: primitive :: u32 , } , # [codec (index = 12)] set_minimum_penalty { # [codec (compact)] new : :: core :: primitive :: u128 , } , # [codec (index = 13)] set_sessions_per_era { # [codec (compact)] new : :: core :: primitive :: u32 , } , # [codec (index = 14)] set_immortals { new : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 15)] force_unlock_bonded_withdrawal { who : :: subxt :: sp_core :: crypto :: AccountId32 , } , # [codec (index = 16)] force_reset_staking_lock { accounts : :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > , } , # [codec (index = 17)] force_set_lock { new_locks : :: std :: vec :: Vec < (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) > , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Error { # [codec (index = 0)] ZeroBalance , # [codec (index = 1)] ZeroVoteWeight , # [codec (index = 2)] NotValidator , # [codec (index = 3)] AlreadyValidator , # [codec (index = 4)] TooManyValidators , # [codec (index = 5)] NoMoreAcceptableVotes , # [codec (index = 6)] TooFewActiveValidators , # [codec (index = 7)] InsufficientBalance , # [codec (index = 8)] NoMoreRebond , # [codec (index = 9)] InvalidRebondBalance , # [codec (index = 10)] RebondSelfBondedNotAllowed , # [codec (index = 11)] InvalidUnbondBalance , # [codec (index = 12)] NoMoreUnbondChunks , # [codec (index = 13)] EmptyUnbondedChunks , # [codec (index = 14)] InvalidUnbondedIndex , # [codec (index = 15)] UnbondedWithdrawalNotYetDue , # [codec (index = 16)] InvalidReferralIdentityLength , # [codec (index = 17)] OccupiedReferralIdentity , # [codec (index = 18)] XssCheckFailed , # [codec (index = 19)] AllocateDividendFailed , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Minted (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 1)] Slashed (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 2)] Bonded (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 3)] Rebonded (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 4)] Unbonded (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 5)] Claimed (:: subxt :: sp_core :: crypto :: AccountId32 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 6)] Withdrawn (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , # [codec (index = 7)] ForceChilled (:: core :: primitive :: u32 , :: std :: vec :: Vec < :: subxt :: sp_core :: crypto :: AccountId32 > ,) , # [codec (index = 8)] ForceAllWithdrawn (:: subxt :: sp_core :: crypto :: AccountId32 ,) , } } pub mod types { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ActiveEraInfo { pub index : :: core :: primitive :: u32 , pub start : :: core :: option :: Option < :: core :: primitive :: u64 > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct BondRequirement < _0 > { pub self_bonded : _0 , pub total : _0 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Forcing { # [codec (index = 0)] NotForcing , # [codec (index = 1)] ForceNew , # [codec (index = 2)] ForceNone , # [codec (index = 3)] ForceAlways , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct GlobalDistribution { pub treasury : :: core :: primitive :: u32 , pub mining : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum LockedType { # [codec (index = 0)] Bonded , # [codec (index = 1)] BondedWithdrawal , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct MiningDistribution { pub asset : :: core :: primitive :: u32 , pub staking : :: core :: primitive :: u32 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct NominatorLedger < _0 , _1 , _2 > { pub nomination : _0 , pub last_vote_weight : _0 , pub last_vote_weight_update : _2 , pub unbonded_chunks : :: std :: vec :: Vec < runtime_types :: xpallet_mining_staking :: types :: Unbonded < _0 , _2 > > , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _1 > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct Unbonded < _0 , _1 > { pub value : _0 , pub locked_until : _1 , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ValidatorLedger < _0 , _1 , _2 > { pub total_nomination : _0 , pub last_total_vote_weight : _0 , pub last_total_vote_weight_update : _2 , # [codec (skip)] pub __subxt_unused_type_params : :: core :: marker :: PhantomData < _1 > , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub struct ValidatorProfile < _0 > { pub registered_at : _0 , pub is_chilled : :: core :: primitive :: bool , pub last_chilled : :: core :: option :: Option < _0 > , pub referral_id : :: std :: vec :: Vec < :: core :: primitive :: u8 > , } } } pub mod xpallet_system { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Call { # [codec (index = 0)] modify_paused { pallet : :: std :: vec :: Vec < :: core :: primitive :: u8 > , call : :: core :: option :: Option < :: std :: vec :: Vec < :: core :: primitive :: u8 > > , should_paused : :: core :: primitive :: bool , } , # [codec (index = 1)] toggle_blacklist { who : :: subxt :: sp_runtime :: MultiAddress < :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u32 > , should_blacklist : :: core :: primitive :: bool , } , } # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] Blacklisted (:: subxt :: sp_core :: crypto :: AccountId32 ,) , # [codec (index = 1)] Unblacklisted (:: subxt :: sp_core :: crypto :: AccountId32 ,) , } } } pub mod xpallet_transaction_fee { use super :: runtime_types ; pub mod pallet { use super :: runtime_types ; # [derive (:: subxt :: codec :: Encode , :: subxt :: codec :: Decode)] pub enum Event { # [codec (index = 0)] FeePaid (:: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 , :: subxt :: sp_core :: crypto :: AccountId32 , :: core :: primitive :: u128 ,) , } } } } # [doc = r" Default configuration of common types for a target Substrate runtime."] # [derive (Clone , Debug , Default , Eq , PartialEq)] pub struct DefaultConfig ; impl :: subxt :: Config for DefaultConfig { type Index = u32 ; type BlockNumber = u32 ; type Hash = :: subxt :: sp_core :: H256 ; type Hashing = :: subxt :: sp_runtime :: traits :: BlakeTwo256 ; type AccountId = :: subxt :: sp_runtime :: AccountId32 ; type Address = :: subxt :: sp_runtime :: MultiAddress < Self :: AccountId , u32 > ; type Header = :: subxt :: sp_runtime :: generic :: Header < Self :: BlockNumber , :: subxt :: sp_runtime :: traits :: BlakeTwo256 > ; type Signature = :: subxt :: sp_runtime :: MultiSignature ; type Extrinsic = :: subxt :: sp_runtime :: OpaqueExtrinsic ; } impl :: subxt :: ExtrinsicExtraData < DefaultConfig > for DefaultConfig { type AccountData = AccountData ; type Extra = :: subxt :: DefaultExtra < DefaultConfig > ; } pub type AccountData = self :: system :: storage :: Account ; impl :: subxt :: AccountData < DefaultConfig > for AccountData { fn nonce (result : & < Self as :: subxt :: StorageEntry > :: Value) -> < DefaultConfig as :: subxt :: Config > :: Index { result . nonce } fn storage_entry (account_id : < DefaultConfig as :: subxt :: Config > :: AccountId) -> Self { Self (account_id) } } pub struct RuntimeApi < T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { pub client : :: subxt :: Client < T > , } impl < T > :: core :: convert :: From < :: subxt :: Client < T >> for RuntimeApi < T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { fn from (client : :: subxt :: Client < T >) -> Self { Self { client } } } impl < 'a , T > RuntimeApi < T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn storage (& 'a self) -> StorageApi < 'a , T > { StorageApi { client : & self . client } } pub fn tx (& 'a self) -> TransactionApi < 'a , T > { TransactionApi { client : & self . client } } } pub struct StorageApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { client : & 'a :: subxt :: Client < T > , } impl < 'a , T > StorageApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn system (& self) -> system :: storage :: StorageApi < 'a , T > { system :: storage :: StorageApi :: new (self . client) } pub fn scheduler (& self) -> scheduler :: storage :: StorageApi < 'a , T > { scheduler :: storage :: StorageApi :: new (self . client) } pub fn babe (& self) -> babe :: storage :: StorageApi < 'a , T > { babe :: storage :: StorageApi :: new (self . client) } pub fn timestamp (& self) -> timestamp :: storage :: StorageApi < 'a , T > { timestamp :: storage :: StorageApi :: new (self . client) } pub fn indices (& self) -> indices :: storage :: StorageApi < 'a , T > { indices :: storage :: StorageApi :: new (self . client) } pub fn balances (& self) -> balances :: storage :: StorageApi < 'a , T > { balances :: storage :: StorageApi :: new (self . client) } pub fn transaction_payment (& self) -> transaction_payment :: storage :: StorageApi < 'a , T > { transaction_payment :: storage :: StorageApi :: new (self . client) } pub fn authorship (& self) -> authorship :: storage :: StorageApi < 'a , T > { authorship :: storage :: StorageApi :: new (self . client) } pub fn offences (& self) -> offences :: storage :: StorageApi < 'a , T > { offences :: storage :: StorageApi :: new (self . client) } pub fn session (& self) -> session :: storage :: StorageApi < 'a , T > { session :: storage :: StorageApi :: new (self . client) } pub fn grandpa (& self) -> grandpa :: storage :: StorageApi < 'a , T > { grandpa :: storage :: StorageApi :: new (self . client) } pub fn im_online (& self) -> im_online :: storage :: StorageApi < 'a , T > { im_online :: storage :: StorageApi :: new (self . client) } pub fn democracy (& self) -> democracy :: storage :: StorageApi < 'a , T > { democracy :: storage :: StorageApi :: new (self . client) } pub fn council (& self) -> council :: storage :: StorageApi < 'a , T > { council :: storage :: StorageApi :: new (self . client) } pub fn technical_committee (& self) -> technical_committee :: storage :: StorageApi < 'a , T > { technical_committee :: storage :: StorageApi :: new (self . client) } pub fn elections (& self) -> elections :: storage :: StorageApi < 'a , T > { elections :: storage :: StorageApi :: new (self . client) } pub fn technical_membership (& self) -> technical_membership :: storage :: StorageApi < 'a , T > { technical_membership :: storage :: StorageApi :: new (self . client) } pub fn treasury (& self) -> treasury :: storage :: StorageApi < 'a , T > { treasury :: storage :: StorageApi :: new (self . client) } pub fn identity (& self) -> identity :: storage :: StorageApi < 'a , T > { identity :: storage :: StorageApi :: new (self . client) } pub fn multisig (& self) -> multisig :: storage :: StorageApi < 'a , T > { multisig :: storage :: StorageApi :: new (self . client) } pub fn x_system (& self) -> x_system :: storage :: StorageApi < 'a , T > { x_system :: storage :: StorageApi :: new (self . client) } pub fn x_assets_registrar (& self) -> x_assets_registrar :: storage :: StorageApi < 'a , T > { x_assets_registrar :: storage :: StorageApi :: new (self . client) } pub fn x_assets (& self) -> x_assets :: storage :: StorageApi < 'a , T > { x_assets :: storage :: StorageApi :: new (self . client) } pub fn x_staking (& self) -> x_staking :: storage :: StorageApi < 'a , T > { x_staking :: storage :: StorageApi :: new (self . client) } pub fn x_mining_asset (& self) -> x_mining_asset :: storage :: StorageApi < 'a , T > { x_mining_asset :: storage :: StorageApi :: new (self . client) } pub fn x_gateway_records (& self) -> x_gateway_records :: storage :: StorageApi < 'a , T > { x_gateway_records :: storage :: StorageApi :: new (self . client) } pub fn x_gateway_common (& self) -> x_gateway_common :: storage :: StorageApi < 'a , T > { x_gateway_common :: storage :: StorageApi :: new (self . client) } pub fn x_gateway_bitcoin (& self) -> x_gateway_bitcoin :: storage :: StorageApi < 'a , T > { x_gateway_bitcoin :: storage :: StorageApi :: new (self . client) } pub fn x_spot (& self) -> x_spot :: storage :: StorageApi < 'a , T > { x_spot :: storage :: StorageApi :: new (self . client) } pub fn proxy (& self) -> proxy :: storage :: StorageApi < 'a , T > { proxy :: storage :: StorageApi :: new (self . client) } pub fn bounties (& self) -> bounties :: storage :: StorageApi < 'a , T > { bounties :: storage :: StorageApi :: new (self . client) } pub fn tips (& self) -> tips :: storage :: StorageApi < 'a , T > { tips :: storage :: StorageApi :: new (self . client) } pub fn sudo (& self) -> sudo :: storage :: StorageApi < 'a , T > { sudo :: storage :: StorageApi :: new (self . client) } } pub struct TransactionApi < 'a , T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T >> { client : & 'a :: subxt :: Client < T > , } impl < 'a , T > TransactionApi < 'a , T > where T : :: subxt :: Config + :: subxt :: ExtrinsicExtraData < T > , { pub fn system (& self) -> system :: calls :: TransactionApi < 'a , T > { system :: calls :: TransactionApi :: new (self . client) } pub fn scheduler (& self) -> scheduler :: calls :: TransactionApi < 'a , T > { scheduler :: calls :: TransactionApi :: new (self . client) } pub fn babe (& self) -> babe :: calls :: TransactionApi < 'a , T > { babe :: calls :: TransactionApi :: new (self . client) } pub fn timestamp (& self) -> timestamp :: calls :: TransactionApi < 'a , T > { timestamp :: calls :: TransactionApi :: new (self . client) } pub fn indices (& self) -> indices :: calls :: TransactionApi < 'a , T > { indices :: calls :: TransactionApi :: new (self . client) } pub fn balances (& self) -> balances :: calls :: TransactionApi < 'a , T > { balances :: calls :: TransactionApi :: new (self . client) } pub fn authorship (& self) -> authorship :: calls :: TransactionApi < 'a , T > { authorship :: calls :: TransactionApi :: new (self . client) } pub fn session (& self) -> session :: calls :: TransactionApi < 'a , T > { session :: calls :: TransactionApi :: new (self . client) } pub fn grandpa (& self) -> grandpa :: calls :: TransactionApi < 'a , T > { grandpa :: calls :: TransactionApi :: new (self . client) } pub fn im_online (& self) -> im_online :: calls :: TransactionApi < 'a , T > { im_online :: calls :: TransactionApi :: new (self . client) } pub fn democracy (& self) -> democracy :: calls :: TransactionApi < 'a , T > { democracy :: calls :: TransactionApi :: new (self . client) } pub fn council (& self) -> council :: calls :: TransactionApi < 'a , T > { council :: calls :: TransactionApi :: new (self . client) } pub fn technical_committee (& self) -> technical_committee :: calls :: TransactionApi < 'a , T > { technical_committee :: calls :: TransactionApi :: new (self . client) } pub fn elections (& self) -> elections :: calls :: TransactionApi < 'a , T > { elections :: calls :: TransactionApi :: new (self . client) } pub fn technical_membership (& self) -> technical_membership :: calls :: TransactionApi < 'a , T > { technical_membership :: calls :: TransactionApi :: new (self . client) } pub fn treasury (& self) -> treasury :: calls :: TransactionApi < 'a , T > { treasury :: calls :: TransactionApi :: new (self . client) } pub fn identity (& self) -> identity :: calls :: TransactionApi < 'a , T > { identity :: calls :: TransactionApi :: new (self . client) } pub fn utility (& self) -> utility :: calls :: TransactionApi < 'a , T > { utility :: calls :: TransactionApi :: new (self . client) } pub fn multisig (& self) -> multisig :: calls :: TransactionApi < 'a , T > { multisig :: calls :: TransactionApi :: new (self . client) } pub fn x_system (& self) -> x_system :: calls :: TransactionApi < 'a , T > { x_system :: calls :: TransactionApi :: new (self . client) } pub fn x_assets_registrar (& self) -> x_assets_registrar :: calls :: TransactionApi < 'a , T > { x_assets_registrar :: calls :: TransactionApi :: new (self . client) } pub fn x_assets (& self) -> x_assets :: calls :: TransactionApi < 'a , T > { x_assets :: calls :: TransactionApi :: new (self . client) } pub fn x_staking (& self) -> x_staking :: calls :: TransactionApi < 'a , T > { x_staking :: calls :: TransactionApi :: new (self . client) } pub fn x_mining_asset (& self) -> x_mining_asset :: calls :: TransactionApi < 'a , T > { x_mining_asset :: calls :: TransactionApi :: new (self . client) } pub fn x_gateway_records (& self) -> x_gateway_records :: calls :: TransactionApi < 'a , T > { x_gateway_records :: calls :: TransactionApi :: new (self . client) } pub fn x_gateway_common (& self) -> x_gateway_common :: calls :: TransactionApi < 'a , T > { x_gateway_common :: calls :: TransactionApi :: new (self . client) } pub fn x_gateway_bitcoin (& self) -> x_gateway_bitcoin :: calls :: TransactionApi < 'a , T > { x_gateway_bitcoin :: calls :: TransactionApi :: new (self . client) } pub fn x_spot (& self) -> x_spot :: calls :: TransactionApi < 'a , T > { x_spot :: calls :: TransactionApi :: new (self . client) } pub fn currencies (& self) -> currencies :: calls :: TransactionApi < 'a , T > { currencies :: calls :: TransactionApi :: new (self . client) } pub fn proxy (& self) -> proxy :: calls :: TransactionApi < 'a , T > { proxy :: calls :: TransactionApi :: new (self . client) } pub fn bounties (& self) -> bounties :: calls :: TransactionApi < 'a , T > { bounties :: calls :: TransactionApi :: new (self . client) } pub fn tips (& self) -> tips :: calls :: TransactionApi < 'a , T > { tips :: calls :: TransactionApi :: new (self . client) } pub fn sudo (& self) -> sudo :: calls :: TransactionApi < 'a , T > { sudo :: calls :: TransactionApi :: new (self . client) } } }
